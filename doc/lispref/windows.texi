@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1998, 1999, 2001,
@c   2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
@c   Free Software Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@setfilename ../../info/windows
@node Windows, Positions, Frames, Top
@chapter Windows

  This chapter describes the functions and variables related to Emacs
windows.  @xref{Display}, for information on how text is displayed in
windows.

@menu
* Basic Windows::           Basic information on using windows.
* Frames and Windows::      Relating windows to the frame they appear on.
* Window Sizes::            Accessing a window's size.
* Resizing Windows::        Changing the sizes of windows.
* Splitting Windows::       Splitting one window into two windows.
* Deleting Windows::        Deleting a window gives its space to other windows.
* Selecting Windows::       The selected window is the one that you edit in.
* Cyclic Window Ordering::  Moving around the existing windows.
* Buffers and Windows::     Each live window displays the contents of a buffer.
* Switching Buffers::       Higher-level functions for switching to a buffer
                              in some window.
* Displaying Buffers::	    How to choose a window for displaying a buffer.
* Dedicated Windows::	    How to avoid displaying another buffer in
                              a specific window.
* Window Point::            Each window has its own location of point.
* Window Start and End::    Buffer positions indicating which text is
                              on-screen in a window.
* Textual Scrolling::       Moving text up and down through the window.
* Vertical Scrolling::      Moving the contents up and down on the window.
* Horizontal Scrolling::    Moving the contents sideways on the window.
* Coordinates and Windows:: Determining a window's edges and
                              converting coordinates to windows.
* Window Configurations::   Saving and restoring the state of the screen.
* Window Parameters::       Associating additional information with windows.
* Composite Windows::       Composing aggregations of windows.
* Compound Windows::        Making several windows behave like a single one.
* Window Groups::           Implementing IDE style window compositions.
* Window Hooks::            Hooks for scrolling, window size changes,
                              redisplay going past a certain point,
                              or window configuration changes.
@end menu

@node Basic Windows
@section Basic Concepts of Emacs Windows
@cindex window

A @dfn{window} in Emacs is the physical area of the screen in which a
buffer is displayed.  The term is also used to refer to a Lisp object
that represents that screen area in Emacs Lisp.  It should be clear from
the context which is meant.

@cindex multiple windows
  Emacs groups windows into frames; see @ref{Frames}.  Each frame always
contains at least one window, but you can subdivide it into multiple,
non-overlapping Emacs windows.  Users create multiple windows so they
can look at several buffers at once.  Lisp libraries use multiple
windows for a variety of reasons, but most often to display related
information.  In Rmail, for example, you can move through a summary
buffer in one window while the other window shows messages one at a time
as they are reached.

@cindex terminal screen
@cindex screen of terminal
  The meaning of ``window'' in Emacs is similar to what it means in the
context of general-purpose window systems such as X, but not identical.
The X Window System places X windows on the screen; Emacs uses one or
more X windows as frames, and subdivides them into Emacs windows.  When
you use Emacs on a character-only terminal, Emacs treats the whole
terminal screen as one frame.

@cindex tiled windows
  Most window systems support arbitrarily located overlapping windows.
In contrast, Emacs windows are @dfn{tiled}; they never overlap, and
together they fill the whole screen or frame.  Because of the way in
which Emacs creates new windows (@pxref{Splitting Windows}) and resizes
them (@pxref{Resizing Windows}), not all conceivable tilings of windows
on an Emacs frame are actually possible.

  For practical purposes, a window exists only while it is displayed in
a frame.  Once removed from the frame, the window is effectively deleted
and should not be used, @emph{even though there may still be references
to it} from other Lisp objects; see @ref{Deleting Windows}.  Restoring a
saved window configuration is the only way for a window no longer on the
screen to come back to life; see @ref{Window Configurations}.

@defun windowp object
This function returns @code{t} if @var{object} is a window and
@code{nil} otherwise.
@end defun

@cindex live windows
@cindex internal windows
   For historical reasons a window is considered @dfn{live} if and only
if it currently displays a buffer; see @ref{Buffers and Windows}.  In
order to show multiple windows within one and the same frame, Emacs
organizes them in form of a tree called window tree; see @ref{Frames and
Windows}.  The internal nodes of a window tree are called internal
windows and are not considered live.  The leaf nodes of a window tree
constitute the windows displaying buffers and only they will be called
live here.  The selected window (@pxref{Selecting Windows}) is always a
live window.

@defun window-live-p object
This function returns @code{t} if @var{object} is a live window and
@code{nil} otherwise.  A live window is a window that is currently used
to display a buffer.
@end defun

@defun window-internal-p object
This function returns @code{t} if @var{object} denotes an internal
window and @code{nil} otherwise.  An internal window is a window that
currently has at least two child windows, see @ref{Frames and Windows}.
@end defun

@defun window-any-p object
This function returns @code{t} if @var{object} denotes a live or an
internal window and @code{nil} otherwise.  In particular, this function
returns @code{nil} if @var{object} is a window that has been
deleted.
@end defun

   The window handling functions can be roughly grouped into functions
operating on live windows only and functions that accept any window as
argument.  Many of these function accept the value @code{nil} to specify
the selected window.  The two functions below can be used to
``normalize'' arguments specifying windows in a uniform manner.

@defun normalize-any-window window
This function returns the normalized value for @var{window} which can be
any window that has not been deleted.  More precisely, if @var{window}
is @code{nil} it returns the selected window.  If @var{window} is
non-@code{nil} and denotes a live or an internal window, this function
returns @var{window}.  In any other case this function signals an error.
@end defun

@defun normalize-live-window window
This functions returns the normalized value for a live window
@var{window}.  More precisely, if @var{window} is @code{nil} it returns
the selected window.  Otherwise, if @var{window} is a live window this
function returns @var{window}.  If @var{window} is neither @code{nil}
nor a live window this function signals an error.
@end defun

@node Frames and Windows
@section Frames and Windows

Each window is part of one and only one frame (@pxref{Frames}); you can
get that frame with the following function.

@defun window-frame window
This function returns the frame that @var{window} is on.  The argument
@var{window} can be any window and defaults to the selected one.
@end defun

A list of all live windows on a specific frame can be obtained by
calling the following function.

@defun window-list &optional frame minibuf window
This function returns a list of @var{frame}'s live windows, starting
with @var{window}.  The argument @var{frame} has to denote a live frame
and defaults to the selected frame.  The argument @var{window} has to
denote a live window on the frame specified by @var{frame} and defaults
to the selected one.

The argument @var{minibuf} specifies if the minibuffer window shall be
included in the return value.  If @var{minibuf} is @code{t}, the result
always includes the minibuffer window.  If @var{minibuf} is @code{nil}
or omitted, that includes the minibuffer window only if it is active.
If @var{minibuf} is neither @code{nil} nor @code{t}, the result never
includes the minibuffer window.
@end defun

@cindex window tree
Windows within one and the same frame are organized in form of a tree
called @dfn{window tree}.  The leaf nodes of a window tree constitute
the windows visible to the user.  These are the windows associated with
buffers and are usually called live or leaf windows.  The internal nodes
of a window tree are needed for finding, traversing and displaying the
leaf windows.

   A minibuffer window (@pxref{Minibuffer Windows}) is not considered
part of its frame's window tree unless the frame is a minibuffer-only
frame.  Most functions covered in this section accept, however, the
minibuffer window as argument.  Also, the minibuffer window is listed by
the function @code{window-tree} described at the end of this section.

   Most window functions can be used without understanding the internals
of window trees.  Some aspects, in particular the implementation of
compound windows (@pxref{Compound Windows}) and window groups
(@pxref{Window Groups}) require, however, a basic understanding of
window trees.

   A window tree is rooted at the root window of its frame.

@defun frame-root-window &optional frame-or-window
This function returns the root window of @var{frame-or-window}.  The
argument @var{frame-or-window} has to denote either a window or a frame
and defaults to the selected frame.  If @var{frame-or-window} denotes a
window, the return value is the root window of that window's frame.
This function always returns a window; a live window if the frame
specified by @var{frame-or-window} contains no other live windows and an
internal window otherwise.
@end defun

@cindex subwindow
All other windows of a frame with the exception of the minibuffer window
are subwindows of the frame's root window.  A window is considered a
@dfn{subwindow} of another window if and only if it occupies a part of
that other window's screen area.

The functions described next allow to access the members of a window
tree with an arbitrary window as argument.

@cindex parent window
@defun window-parent &optional window
Return @var{window}'s parent in the window tree.  The optional argument
@var{window} can denote an arbitrary window and defaults to the selected
one.  The return value is either an internal window or @code{nil} if
@var{window} is a minibuffer window or the root window of its frame.
@end defun

@cindex child window
   Parent windows do not appear on the screen.  The screen area of a
parent window is the rectangular part of the window's frame occupied by
the window's @dfn{child windows}, that is the set of windows having that
window as their parent.  Each parent window has at least two child
windows, so there are no ``Matryoshka'' windows.  Minibuffer windows do
not have child windows.

@cindex window combination
@cindex vertical combination
@cindex horizontal combination
The children of any parent window form either a vertical or a horizontal
combination of windows.  A @dfn{vertical combination} is a set of
windows arranged one above each other.  A @dfn{horizontal combination}
is a set of windows arranged side by side.  For any parent window, the
first child window is accessible by the functions given next.

@defun window-vchild &optional window
This function returns @var{window}'s first vertical child window.  The
optional argument @var{window} can be an arbitrary window and defaults
to the selected one.  The return value is @code{nil} if @var{window} is
a leaf window or its children form a horizontal combination.
@end defun

@defun window-hchild &optional window
This function returns @var{window}'s first horizontal child window.  The
optional argument @var{window} can be an arbitrary window and defaults
to the selected one.  The return value is @code{nil} if @var{window} is
a leaf window or its children form a vertical combination.
@end defun

@defun window-child window
This function return @var{window}'s first child window.  The return
value is @code{nil} if @var{window} is a leaf window.
@end defun

The following function is useful to determine whether a window is part
of a vertical or horizontal combination.

@defun window-iso-combined-p &optional window horizontal
This function returns a non-@code{nil} value if and only if @var{window}
is vertically combined.  The argument @var{window} can specify any
window and defaults to the selected one.  The actual return value is the
first vertical child of window.

If the optional argument @var{horizontal} is non-@code{nil}, this means
to return non-@code{nil} if and only if @var{window} is horizontally
combined.  The actual return value is the first horizontal child of
window.
@end defun

@cindex sibling window
For any window that is part of a combination, the other windows in that
combination are called the window's @dfn{siblings}.  The only windows
that do not have any siblings are the frames' root windows and the
minibuffer windows.  A window's siblings can be retrieved with the
following two functions.

@defun window-next &optional window
This function returns @var{window}'s right sibling.  The optional
argument @var{window} can be an arbitrary window and defaults to the
selected window.  It returns @code{nil} if @var{window} has no right
sibling.  Applying this function recursively will eventually get you to
the last child of @var{window}'s parent.
@end defun

@defun window-prev &optional window
This function returns @var{window}'s left sibling.  The optional
argument @var{window} can be an arbitrary window and defaults to the
selected window.  It returns @code{nil} if @var{window} has no left
sibling.  Applying this function recursively will eventually get you to
the first child of @var{window}'s parent.
@end defun

The functions @code{window-next} and @code{window-prev} should not be
confused with the functions @code{next-window} and
@code{previous-window} which respectively return the next and previous
window in the cyclic ordering of windows, see @ref{Cyclic Window
Ordering}.

   In order to find the first live window on a frame, the following
function can be used.

@defun frame-first-window &optional frame-or-window
This function returns the window at the upper left corner of the frame
specified by @var{frame-or-window}.  The argument @var{frame-or-window}
must denote a window or a live frame and defaults to the selected frame.
If @var{frame-or-window} specifies a window, this function returns the
first window on that window's frame.
@end defun

You can get the window tree of a frame with the following function.

@cindex window tree
@defun window-tree &optional frame
This function returns the window tree for frame @var{frame}.  The
optional argument @var{frame} must be a live frame and defaults to the
selected one.

The return value is a list of the form @code{(@var{root} @var{mini})},
where @var{root} represents the window tree of the frame's
root window, and @var{mini} is the frame's minibuffer window.

If the root window is live, @var{root} specifies the root window and
nothing else.  Otherwise, @var{root} is a list @code{(@var{dir}
@var{edges} @var{w1} @var{w2} ...)} where @var{dir} is @code{nil} for a
horizontal combination, and @code{t} for a vertical combination,
@var{edges} gives the size and position of the combination, and the
remaining elements are the child windows.  Each child window may again
be a live window or a list representing a window combination, and so on.
The @var{edges} element is a list @code{(@var{left}@var{ top}@var{
right}@var{ bottom})} similar to the value returned by
@code{window-edges}, see @ref{Coordinates and Windows}.
@end defun

@node Window Sizes
@section Window Sizes
@cindex window size
@cindex size of window

Emacs windows are rectangular.  The structure of a live window can be
roughly sketched as follows:

@smallexample
@group
         _________________________________________ 
      ^ |______________ Header Line_______________| 
      | |LS|LF|LM|                       |RM|RF|RS| ^
      | |  |  |  |                       |  |  |  | |
 Window |  |  |  |       Text Area       |  |  |  | Window
 Total  |  |  |  |     (Window Body)     |  |  |  | Body
 Height |  |  |  |                       |  |  |  | Height
      | |  |  |  |<- Window Body Width ->|  |  |  | |
      | |__|__|__|_______________________|__|__|__| v
      v |_______________ Mode Line _______________|

         <----------- Window Total Width -------->

@end group
@end smallexample

@cindex window body
@cindex body of a window
The text area constitutes the body of the window.  In its most simple
form, a window consists of its body alone.  LS and RS stand for the left
and right scroll bar (@pxref{Scroll Bars}) respectively.  Only one of
them can be present, in practice.  LF and RF denote the left and right
fringe, see @ref{Fringes}.  LM and RM, finally, stand for the left and
right display margin, see @ref{Display Margins}.  Any header line is
located above theses areas, any mode line below, see @ref{Mode Line
Format}.

@cindex window height
@cindex total window height
@cindex height of a window
@cindex total height of a window
The @dfn{total height of a window} is specified as the total number of
lines occupied by the window.  Any mode or header line is included in a
window's total height.  For an internal window, the total height is
calculated recursively from the total heights of its child windows.

@cindex window width
@cindex total window width
@cindex width of a window
@cindex total width of a window
The @dfn{total width of a window} denotes the total number of columns of
the window.  Any scroll bar and the column of @samp{|} characters that
separate the window from its right sibling are included in a window's
total width.  On a window-system also fringes and display margins are
included in a window's total width.  For an internal window, the total
width is calculated recursively from the total widths of its child
windows.

@cindex total size of a window
@cindex total window size
The following function is the standard interface for getting the total
size of any window:

@defun window-total-size &optional window &optional horizontal
This function returns the total number of lines of @var{window}.  The
argument @var{window} can denote any window and defaults to the selected
one.  If @var{window} is live, the return value includes any header or
mode lines of @var{window}.  If @var{window} is internal, the return
value is the sum of the total heights of @var{window}'s child windows
provided these are vertically combined and the height of @var{window}'s
first child if they are horizontally combined.

If optional argument @var{horizontal} is non-@code{nil}, this function
returns the total number of columns of @var{window}.  If @var{window} is
live, the return value includes any vertical divider column or scroll
bars owned by @var{window}.  On a window-system the return value also
includes the space occupied by any margins and fringes of @var{window}.
If @var{window} is internal, the return value is the sum of the total
widths of @var{window}'s child windows provided these are horizontally
combined and the width of @var{window}'s first child otherwise.
@end defun

Alternatively, the following two functions can be used to retrieve
either the total height of the total width of a window:

@defun window-total-height &optional window
This function returns the total number of lines of @var{window}.
@var{window} can be any window and defaults to the selected one.  The
return value includes @var{window}'s mode line and header line, if any.
If @var{window} is internal the return value is the sum of heights of
@var{window}'s child windows for a vertical combination and the height
of @var{window}'s first child otherwise.
@end defun

@defun window-total-width &optional window
This function returns the total number of columns of @var{window}.
@var{window} can be any window and defaults to the selected one.  The
return value includes any vertical dividers or scrollbars of
@var{window}.  On a window-system the return value also includes the
space occupied by any margins and fringes of @var{window}.  If
@var{window} is internal, the return value is the sum of the widths of
@var{window}'s child windows for a horizontal combination and the width
of @var{window}'s first child otherwise.
@end defun

The total height of any window is usually less than the height of the
associated frame, because the latter may also include the minibuffer
window.  Depending on the toolkit in use, the frame height can also
include the menu bar and the tool bar (@pxref{Size and Position}).
Therefore, in general it is not straightforward to compare window and
frame heights.  The following function can be used to determine whether
a window is as high as the containing frame:

@cindex full-height window
@defun window-full-height-p &optional window
This function returns non-@code{nil} if there is no other window above
or below @var{window} on the containing frame.  More precisely, this
function returns @code{t} if and only if the total height of
@var{window} equals the total height of the root window (@pxref{Frames
and Windows}) of @var{window}'s frame.  The @var{window} argument may
denote any window and defaults to the selected one.
@end defun

@cindex full-width window
The following function can be used to determine whether a window is as
wide as the containing frame.

@defun window-full-width-p &optional window
This function returns non-@code{nil} if @var{window} is as wide as the
frame that contains it; otherwise @code{nil}.  More precisely, this
function returns @code{t} if and only if the total width of @var{window}
equals the total width of the root window (@pxref{Frames and Windows})
of @var{window}'s frame.  The @var{window} argument may denote any
window and defaults to the selected one.
@end defun

@cindex top line of window
@cindex left column of window
  Each window in a frame is unambiguously characterized by the
combination of its top line and its left column within that frame.

@defun window-top-line &optional window
This function returns the top line of @var{window}.  The argument
@var{window} can denote any window and defaults to the selected one.
@end defun

@defun window-left-column &optional window
This function returns the left column of @var{window}.  The argument
@var{window} can denote any window and defaults to the selected one.
@end defun

For a frame displaying one window only, that window's top line and left
column are both zero.  When a frame displays a window @var{WB} below a
window @var{WA}, the top line of @var{WB} can be calculated by adding
the total height of @var{WA} to the top line of @var{WA}.  When a frame
displays a window @var{WR} on the right of a window @var{WL}, the left
column of @var{WR} can be calculated by adding the total width of
@var{WL} to the left column of @var{WL}.

@cindex window body height
@cindex body height of a window
The @dfn{body height of a window} is specified as the total number of
lines occupied by the window's text area.  Any mode or header line is
not included in a window's body height.

@cindex window body width
@cindex body width of a window
The @dfn{body width of a window} denotes the total number of columns
occupied by the window's text area.  Any scroll bar or column of
@samp{|} characters that separates side-by-side windows is not included
in a window's body width.

@cindex body size of a window
@cindex window body size
The following functions retrieve height and width of the body of a live
window:

@defun window-body-size &optional window horizontal
This function returns the number of lines of @var{window}'s text area.
@var{window} must be a live window and defaults to the selected one.
The return value does not count any mode or header line of @var{window}.

Optional argument @var{horizontal} non-@code{nil} means to return the
number of columns of @var{window}'s text area.  In this case the return
value does not include any vertical divider or scroll bar owned by
@var{window}.  On a window-system the return value does not include the
number of columns used for @var{window}'s fringes or display margins
either.
@end defun

@defun window-body-height &optional window
This function returns the number of lines of @var{window}'s body.
@var{window} must be a live window and defaults to the selected one.

The return value does not include @var{window}'s mode line and header
line, if any.  If a line at the bottom of the window is only partially
visible, that line is included in the return value.  If you do not
want to include a partially visible bottom line in the return value,
use @code{window-text-height} instead.
@end defun

@defun window-body-width &optional window
This function returns the number of columns of @var{window}'s body.
@var{window} must be a live window and defaults to the selected one.

The return value does not include any vertical dividers or scroll bars
owned by @var{window}.  On a window-system the return value does not
include the number of columns used for @var{window}'s fringes or
display margins either.
@end defun

The following functions have been used in earlier versions of Emacs.
They are still supported but due to the confusing nomenclature they
should not be used any more in future code.

@defun window-height &optional window
This function is an alias for `window-total-height', see above.
@end defun

@defun window-width &optional window
This function is an alias for `window-body-width', see above.
@end defun

@cindex minimum window size
  The following two options constrain the sizes of windows to a minimum
height and width.  Their values are honored when windows are split
(@pxref{Splitting Windows}) or resized.  Any request to make a window
smaller than specified here will usually result in an error.

@defopt window-min-height
The value of this variable specifies how short a window may be.  The
value is measured in line units and has to account for any header or
mode line.  The default value for this option is @code{4}.  Any value
less than @code{1} is ignored.
@end defopt

@defopt window-min-width
The value of this variable specifies how narrow a window may be.  The
value is measured in characters and includes any margins, fringes,
scroll bar and vertical divider column.  The default value for this
option is @code{10}.  A value less than @code{2} is ignored.
@end defopt

An application should not rebind these variables.  To shrink a specific
window to a height or width less than the one specified here, it should
rather invoke @code{resize-window} with a non-@code{nil} @var{ignore}
argument.  The function @code{split-window} (@pxref{Splitting Windows})
can make a window smaller than specified here by setting its @var{size}
argument to a non-@code{nil} value.  Interactively, the values specified
here cannot be overridden.

   Earlier versions of Emacs could delete a window when its size dropped
below @code{window-min-height} or @code{window-min-width}.  The current
version of Emacs does no more implicitly delete windows.  The only
exception to this rule are requests to resize a frame which may
implicitly delete windows when they do not fit on the frame any more,
see @ref{Size and Position}.

   The size of a window can be fixed which means that it cannot be split
(@pxref{Splitting Windows}) or resized (@pxref{Resizing Windows}).

@cindex fixed-size window
@defvar window-size-fixed
If this variable is non-@code{nil}, in a given buffer, then the size of
any window displaying that buffer remains fixed unless you either
explicitly change it or Emacs has no other choice.

If the value is @code{height}, then only the window's height is fixed;
if the value is @code{width}, then only the window's width is fixed.
Any other non-@code{nil} value fixes both the width and the height.

This variable automatically becomes buffer-local when set.
@end defvar

Commands supposed to explicitly change the size of windows such as
@code{enlarge-window} (@pxref{Resizing Windows}) get an error if they
would have to change a window size which is fixed.  Other functions like
@code{resize-window} (@pxref{Resizing Windows}) have an optional
@var{ignore} argument which allows to change the size of fixed-size
windows.

   Deleting a window or changing a frame's size may change the size of a
fixed-size window, if there is no other alternative.

   A vertical combination of windows cannot be resized when the height
of all windows in that combination is fixed.  A horizontal combination
cannot be resized when the width of all windows in it is fixed.  The
next function allows to check whether the size of an arbitrary window is
fixed.

@defun window-size-fixed-p &optional window horizontal
This function returns non-@code{nil} if @var{window}'s height is fixed.
The argument @var{window} can be an arbitrary window and defaults to the
selected one.  Optional argument @var{horizontal} non-@code{nil} means
return non-@code{nil} if @var{window}'s width is fixed.

If this function returns @code{nil}, this does not necessarily mean that
@var{window} can be resized in the desired direction.  The function
@code{window-resizable} (@pxref{Resizing Windows}) can tell that.
@end defun

@node Resizing Windows
@section Resizing Windows
@cindex window resizing
@cindex resize window
@cindex changing window size
@cindex window size, changing

Emacs does not permit overlapping windows or gaps between windows, so
changing the size of a window always affects at least one other window.
When a frame contains just one window, that window can be resized only
implicitly by resizing the window's frame.  The functions described
below are therefore meaningful exclusively in the context of a frame
containing at least two windows.  The size of that frame never changes
when invoking a function described in this section.

   The routines changing window sizes always operate in one dimension at
a time.  This means that windows can be resized only either vertically
or horizontally.  If a window shall be resized in both dimensions, it
must be resized in one dimension first and in the other dimension
afterwards.  If the second resize operation fails, the frame might end
up in an unsatisfactory state.  To avoid such states, it might be useful
to save the current window configuration (@pxref{Window Configurations})
before attempting the first resize operation and restore the saved
configuration in case the second resize operation fails.

   Functions that resize windows are supposed to obey restrictions
imposed by window minimum sizes and fixed-size windows, see @ref{Window
Sizes}.  In order to determine whether resizing a specific window is
possible in the first place, the following function can be used:

@defun window-resizable window delta &optional horizontal ignore side noup nodown
This function returns @var{delta} if the size of @var{window} can be
changed vertically by @var{delta} lines.  Optional argument
@var{horizontal} non-@code{nil} means to return @var{delta} if
@var{window} can be resized horizontally by @var{delta} columns.  A
return value of zero means that @var{window} is not resizable.

If @var{delta} is a positive number, this means that @var{window} shall
be enlarged by @var{delta} lines or columns.  If @var{window} cannot be
enlarged by @var{delta} lines or columns this function returns the
maximum value in the range from 0 to @var{delta} by which @var{window}
can be enlarged.

If @var{delta} is a negative number, this means that @var{window} shall
be shrunk by -@var{delta} lines or columns.  If @var{window} cannot be
shrunk by -@var{delta} lines or columns, this function returns the
minimum value in the range from @var{delta} to 0 that can be used for
shrinking @var{window}.

Optional argument @var{ignore} non-@code{nil} means ignore any
restrictions imposed by the variables @code{window-min-height} or
@code{window-min-width} and @code{window-size-fixed}.  In this case the
minimum height of a window is specified as the minimum number of lines
that allow viewing any header or mode line and at least one line of the
text area of window.  The minimum width of a window includes any
fringes, margins and the scroll bar as well as two text columns.

If @var{ignore} denotes a window, this means to ignore restrictions for
that window only.  If @var{ignore} equals the constant @code{safe}, this
means a live window may get as small as one line or two columns.

Optional argument @var{noup} non-@code{nil} means don't go up in the
window tree but try to steal or distribute the space needed for the
resize operation among the other windows within @var{window}'s
combination.  Optional argument @var{nodown} non-@code{nil} means don't
check whether @var{window} and its subwindows can be resized.
@end defun

The function @code{window-resizable} does not change any window sizes.
The following function does:

@defun resize-window window delta &optional horizontal ignore
This function resizes @var{window} vertically by @var{delta} lines.  The
argument @var{window} can denote an arbitrary window and defaults to the
selected one.  An attempt to resize the root window of a frame will
raise an error.

Second argument @var{delta} a positive number means @var{window} shall
be enlarged by @var{delta} lines.  If @var{delta} is negative, that
means @var{window} shall be shrunk by -@var{delta} lines.

Optional argument @var{horizontal} non-@code{nil} means to resize
@var{window} horizontally by @var{delta} columns.  In this case a
positive @var{delta} means enlarge @var{window} by @var{delta} columns.
A negative @var{delta} means @var{window} shall be shrunk by
-@var{delta} columns.

Optional argument @var{ignore} has the same meaning as for the function
@code{window-resizable} above.

This function resizes other windows proportionally and never deletes any
windows.  If only the low (right) edge of @var{window} shall be moved,
the function @code{adjust-window-trailing-edge} described below should
be used.
@end defun

The next four commands are simple interfaces to @code{resize-window}.
They always operate on the selected window, never delete any window, and
always raise an error when resizing would violate a restriction imposed
by @code{window-min-height}, @code{window-min-width}, or
@code{window-size-fixed}.

@deffn Command enlarge-window delta &optional horizontal
This function makes the selected window @var{delta} lines taller.
Interactively, if no argument is given, it makes the selected window one
line taller.  If optional argument @var{horizontal} is non-@code{nil},
it makes the selected window wider by @var{delta} columns.  If
@var{delta} is negative, it shrinks the selected window by -@var{delta}
lines or columns.  The return value is @code{nil}.
@end deffn

@deffn Command enlarge-window-horizontally delta
This function makes the selected window @var{delta} columns wider.
Interactively, if no argument is given, it makes the selected window one
column wider.
@end deffn

@deffn Command shrink-window delta &optional horizontal
This function makes the selected window @var{delta} lines smaller.
Interactively, if no argument is given, it makes the selected window one
line smaller.  If optional argument @var{horizontal} is non-@code{nil},
it makes the selected window narrower by @var{delta} columns.  If
@var{delta} is negative, it enlarges the selected window by -@var{delta}
lines or columns.  The return value is @code{nil}.
@end deffn

@deffn Command shrink-window-horizontally delta
This function makes the selected window @var{delta} columns narrower.
Interactively, if no argument is given, it makes the selected window one
column narrower.
@end deffn

@defun adjust-window-trailing-edge window delta &optional horizontal
Move @var{window}'s bottom edge by @var{delta} lines.  Optional
argument @var{horizontal} non-@code{nil} means move @var{window}'s
right edge by @var{delta} columns.  @var{window} defaults to the
selected window.

If the edge can't be moved by @var{delta} lines, move it as far as
possible in the desired direction.
@end defun

@deffn Command fit-window-to-buffer &optional window max-height min-height
This command makes @var{window} the right height to display its
contents exactly.  The default for @var{window} is the selected window.

The optional argument @var{max-height} specifies the maximum height the
window is allowed to be; @code{nil} means use the maximum permissible
height of a window on @var{window}'s frame.  The optional argument
@var{min-height} specifies the minimum height for the window; @code{nil}
means use @code{window-min-height}.  All these height values include the
mode line and/or header line.

This function returns non-@code{nil} if it orderly resized @var{window},
and @code{nil} otherwise.
@end deffn

@deffn Command shrink-window-if-larger-than-buffer &optional window
This command shrinks @var{window} vertically to be as small as possible
while still showing the full contents of its buffer---but not less than
@code{window-min-height} lines.  The argument @var{window} must denote
a live window and defaults to the selected one.

However, this command does nothing if the window is already too small to
display the whole text of the buffer, or if part of the contents are
currently scrolled off screen, or if the window is not the full width of
its frame, or if the window is the only window in its frame.

This command returns non-@code{nil} if it actually shrank the window
and @code{nil} otherwise.
@end deffn

@cindex balancing window sizes
Emacs provides two functions to balance windows, that is, to even out
the sizes of windows on the same frame.  The minibuffer window and
fixed-size windows are not resized by these functions.

@deffn Command balance-windows &optional window-or-frame
This function balances windows in a way that gives more space to
full-width and/or full-height windows.  If @var{window-or-frame}
specifies a frame, it balances all windows on that frame.  If
@var{window-or-frame} specifies a window, it balances that window and
its siblings (@pxref{Frames and Windows}) only.
@end deffn

@deffn Command balance-windows-area
This function attempts to give all windows on the selected frame
approximately the same share of the screen area.  This means that
full-width or full-height windows are not given more space than other
windows.
@end deffn

@cindex maximizing windows
The following function can be used to give a window the maximum possible
size on its frame.

@deffn Command maximize-window &optional window
This function maximizes @var{window}.  More precisely, this makes
@var{window} as large as possible without resizing its frame or deleting
other windows.  @var{window} can be any window and defaults to the
selected one.
@end deffn

@cindex minimizing windows
To make a window as small as possible without deleting it the
following function can be used.

@deffn Command minimize-window &optional window
This function minimizes @var{window}.  More precisely, this makes
@var{window} as small as possible without deleting it or resizing its
frame.  @var{window} can be any window and defaults to the selected one.
@end deffn

@node Splitting Windows
@section Splitting Windows
@cindex splitting windows
@cindex window splitting

The functions described below are the primitives needed for creating a
new window.  They do not accept a buffer as an argument.  Rather, they
apparently ``split'' an existing window into two halves, both displaying
the buffer previously visible in the window that was split.

@deffn Command split-window &optional window size horizontal
This function creates a new window adjacent to @var{window}.  It returns
the new window which is always a live window.  The argument @var{window}
can denote any window and defaults to the selected one.  This function
does not change the selected window.

Optional second argument @var{size} a positive number means make
@var{window} @var{size} lines (or columns) tall.  If @var{size} is
negative, make the new window @minus{}@var{size} lines (or columns)
tall.  If @var{size} is omitted or @code{nil}, then @var{window} is
divided evenly into two parts.  (If there is an odd line, it is
allocated to the new window.)

If splitting would result in making a window smaller than
@code{window-min-height} or @code{window-min-width} (@pxref{Window
Sizes}), this function usually signals an error.  However, if @var{size}
is negative and its absolute value is valid, a new window of the
requested size is created.  (A size value would be invalid if it
assigned less than one line or less than two columns to the new window.)

Optional third argument @var{horizontal} @code{nil} (or @code{below})
specifies that the new window shall be located below @var{window}.  The
value @code{above} means the new window will be located above
@var{window}.  In both cases @var{size} specifies the new number of
lines for @var{window} (or the new window if @var{size} is negative)
including space reserved for the mode and/or header line.

If @var{horizontal} is @code{t} or @code{right} the new window will be
positioned on the right side of @var{window}.  The value @code{left}
means the new window will be located on the left side of @var{window}.
In both cases @var{size} specifies the new number of columns for
@var{window} (or the new window provided @var{size} is negative)
including space reserved for margins, fringes and the scroll bar or a
divider column.

Any other non-@code{nil} value for @var{horizontal} is currently handled
like @code{t} (or @code{right}).  Since this might change in the future,
application programs should refrain from using other values.

If @var{window} is live, properties of the new window like margins and
scroll bars are inherited from @var{window}.  If @var{window} is an
internal window, these properties, as well as the buffer shown in the
new window, are inherited from the window selected on @var{window}'s
frame.

This function respects the variable @code{ignore-window-parameters}
(@pxref{Window Parameters}) when processing window parameters so any
processing of @var{window}'s parameters may be suppressed.

If the @code{split-window} parameter of @var{window} equals @code{t},
any other parameters for @var{window} are ignored and @var{window} is
split as described above.  If the @code{split-window} parameter of
@var{window} specifies a function, that function is called with the
@var{window}, @var{size}, and @var{horizontal} arguments to do the
split.  If that function is @code{ignore}, nothing is done.  It's the
responsibility of that function to adjust all window parameters.

If neither @code{ignore-window-parameters} nor the @code{split-window}
parameter come in the way, this function may behave specially when
@var{window} is a composite window or part of a composite window, see
@ref{Composite Windows}.  If @var{window} is a component of a compound
window (@pxref{Compound Windows}) this function operates on the root of
the compound window instead.  The new window does not become a member of
the compound window.  If @var{window} is a main window of a window group
(@pxref{Window Groups}), the new window becomes a main window in that
window group.  If @var{window} is a non-main component of a window group
this function signals an error.
@end deffn

The following example starts with one window on a screen that is 50
lines high by 80 columns wide; then it splits the window.

@smallexample
@group
(setq w1 (selected-window))
     @result{} #<window 8 on windows.texi>
(setq w2 (split-window w1 15))
     @result{} #<window 28 on windows.texi>
@end group
@group
(window-top-line w1)
     @result{} 0
(window-total-size w1)
     @result{} 15
(window-top-line w2)
     @result{} 15
@end group
@end smallexample

The screen looks like this:

@smallexample
@group
         __________
        |          |  line 0
        |    w1    |
        |__________|
        |          |  line 15
        |    w2    |
        |__________|
                      line 50
 column 0   column 80
@end group
@end smallexample

Next, split the top window horizontally:

@smallexample
@group
(setq w3 (split-window w1 35 t))
     @result{} #<window 32 on windows.texi>
@end group
@group
(window-left-column w1)
     @result{} 0
(window-total-size w1 t)
     @result{} 35
(window-left-column w3)
     @result{} 35
@end group
@end smallexample

@need 3000
Now the screen looks like this:

@smallexample
@group
     column 35
         __________
        |    |     |  line 0
        | w1 |  w3 |
        |____|_____|
        |          |  line 15
        |    w2    |
        |__________|
                      line 50
 column 0   column 80
@end group
@end smallexample

Normally, Emacs indicates the border between two side-by-side windows
with a scroll bar (@pxref{Scroll Bars}), or with @samp{|} characters.  The
display table can specify alternative border characters; see @ref{Display
Tables}.

The following option affects the behavior of a number of functions
operating on a window that is part of a window combination, see
@ref{Frames and Windows}.

@defopt window-splits
If this variable is @code{nil}, @code{split-window} creates a new parent
window if and only if either @var{window} has no parent window or
@var{window} shall be split in another direction than the combination
@var{window} is part of.  @code{resize-window} preferably resizes
@var{window}'s right sibling.  @code{delete-window} preferably returns
space to @var{window}'s left sibling.

If this variable equals @code{nest}, @code{split-window} always creates
a new parent window.  As a consequence, any frame's window tree is a
binary tree and every window has at most one (left or right) sibling.
@code{resize-window} preferably resizes @var{window}'s sibling.
@code{delete-window} preferably returns space to @var{window}'s sibling.

If this variable equals @code{resize}, @code{split-window} tries to
resize all windows belnging to the same combination as @var{window} to
accomodate the new window.  Hence, the new window can be also created if
@var{window} is otherwise too small to be split.  Resizing or deleting
any window of a combination tries to distribute space proportionally
among all other windows of the combination.

Application programs should never rebind this variable to any value but
@code{nest}.
@end defopt

@deffn Command split-window-vertically &optional size
This function splits the selected window into two windows, one above the
other, leaving the upper of the two windows selected, with @var{size}
lines.  (If @var{size} is negative, then the lower of the two windows
gets @minus{}@var{size} lines and the upper window gets the rest, but
the upper window is still the one selected.)  However, if
@code{split-window-keep-point} (see below) is @code{nil}, then either
window can be selected.

In other respects, this function is similar to @code{split-window}.
In particular, the upper window is the original one and the return
value is the new, lower window.
@end deffn

@defopt split-window-keep-point
If this variable is non-@code{nil} (the default), then
@code{split-window-vertically} behaves as described above.

If it is @code{nil}, then @code{split-window-vertically} adjusts point
in each of the two windows to avoid scrolling.  (This is useful on
slow terminals.)  It selects whichever window contains the screen line
that point was previously on.

This variable affects the behavior of @code{split-window-vertically}
only.  It has no effect on the other functions described here.
@end defopt

@deffn Command split-window-horizontally &optional size
This function splits the selected window into two windows
side-by-side, leaving the selected window on the left with @var{size}
columns.  If @var{size} is negative, the rightmost window gets
@minus{}@var{size} columns, but the leftmost window still remains
selected.
@end deffn

@node Deleting Windows
@section Deleting Windows
@cindex deleting windows

A window remains visible on its frame unless you @dfn{delete} it by
calling certain functions that delete windows.  A deleted window cannot
appear on the screen, but continues to exist as a Lisp object until
there are no references to it.  There is no way to cancel the deletion
of a window aside from restoring a saved window configuration
(@pxref{Window Configurations}).  Restoring a window configuration also
deletes any windows that aren't part of that configuration.

@strong{Warning:} Erroneous information or fatal errors may result from
using a deleted window as if it were live.

@deffn Command delete-window &optional window
This function removes @var{window} from display and returns @code{nil}.
The argument @var{window} can denote any window and defaults to the
selected one.  An error is signaled if @var{window} is the only window
on its frame.  Hence @var{window} must have at least one sibling window
(@pxref{Frames and Windows}) in order to get deleted.

If @code{window-splits} is @code{nil}, the space @var{window} took up is
given to its left sibling if such a window exists and to its right
sibling otherwise.  If @code{window-splits} equals @code{nest} that
space is given to the sole remaining sibling of @var{window}.  If
@code{window-splits} equals @code{resize}, the space occupied by
@var{window} is distributed proportionally among the other windows in
the same combination as @var{window}.

This function respects the variable @code{ignore-window-parameters}
(@pxref{Window Parameters}) when processing window parameters.  If
parameters are not ignored and the @code{delete-window} parameter of
@var{window} equals @code{t}, this function deletes @var{window}
ignoring any other window parameters.  If the @code{delete-window}
parameter specifies a function, that function is called with
@var{window} as its sole argument.  It's the responsibility of that
function to adjust the parameters of all remaining windows.

Otherwise, if @var{window} is part of a compound window (@pxref{Compound
Windows}), this function is called with the root of the compound window
as its argument.  If @var{window} is a support window or the last main
window of a window group (@pxref{Window Groups}), this function signals
an error.
@end deffn

@deffn Command delete-other-windows &optional window
This function makes @var{window} fill its frame and returns @code{nil}.
The argument @var{window} can denote an arbitrary window and defaults to
the selected one.

This function respects the variable @code{ignore-window-parameters}
when processing window parameters so any processing of @var{window}'s
parameters may be suppressed.

If the @code{delete-other-windows} parameter of @var{window} equals
@code{t}, this function deletes the remaining windows ignoring all other
parameters.  If the @code{delete-other-windows} parameter specifies a
function, it calls that function with @var{window} as its sole argument.

Otherwise, if @var{window} is part of a compound window, it calls this
function with the root of the compound window as its argument.  If
@var{window} is a main window in a window group, it makes @var{window}
the only main window in that group.  Any support windows of the group
are left alone.  If @var{window} is a support window of a window group,
this function signals an error and doesn't delete any windows.
@end deffn

@deffn Command delete-windows-on &optional buffer-or-name frame
This function deletes all windows showing @var{buffer-or-name} and
returns nil.  If there are no windows showing @var{buffer-or-name}, it
does nothing.  The optional argument @var{buffer-or-name} may be a
buffer or the name of an existing buffer and defaults to the current
buffer.  Invoking this command on a minibuffer signals an error.

@code{delete-windows-on} operates by calling @code{delete-window} for
each window showing @var{buffer-or-name}.  If a frame has several
windows showing different buffers, then those showing
@var{buffer-or-name} are removed, and the other windows expand to fill
the space.  If all windows in some frame are showing
@var{buffer-or-name} (including the case where there is only one
window), then the frame winds up with a single window showing another
buffer chosen with @code{other-buffer}, see @ref{The Buffer List}.  If,
however, that last remaining window is dedicated to the buffer specified
by @var{buffer-or-name} (@pxref{Dedicated Windows}), and there are other
frames left, that window's frame is deleted.

The optional argument @var{frame} specifies which frames to operate on.
This function does not use it in quite the same way as the other
functions which scan all live windows (@pxref{Cyclic Window Ordering});
specifically, the values @code{t} and @code{nil} have the opposite of
their meanings in the other functions.  Here are the full details:

@itemize @bullet
@item @code{nil}
means operate on all frames.
@item @code{t}
means operate on the selected frame.
@item @code{visible}
means operate on all visible frames.
@item @code{0}
means operate on all visible or iconified frames.
@item A frame
means operate on that frame.
@end itemize
@end deffn

@node Selecting Windows
@section Selecting Windows
@cindex selecting a window

@cindex selected window
In each frame, at any time, one and only one window is designated as
@dfn{selected within the frame}.  Also, at any time, one frame is the
selected frame (@pxref{Input Focus}).  The window selected within the
selected frame is the @dfn{selected window}.  The selected window's
buffer is usually the current buffer (except when @code{set-buffer} has
been used); see @ref{Current Buffer}.

@defun selected-window
This function returns the selected window.  This is the window in which
the cursor for selected windows (@pxref{Cursor Parameters}) appears and
to which many commands apply.
@end defun

@defun select-window window &optional norecord
This function makes @var{window} the selected window.  Unless
@var{window} already is the selected window, this also makes
@var{window}'s buffer (@pxref{Buffers and Windows}) the current buffer.
Moreover, the cursor for selected windows will be displayed in
@var{window} after the next redisplay.  This function returns
@var{window}.

Normally, @var{window}'s selected buffer is moved to the front of the
buffer list (@pxref{The Buffer List}) and @var{window} becomes the most
recently selected window.  But if the optional argument @var{norecord}
is non-@code{nil}, the buffer list remains unchanged and @var{window}
does not become the most recently selected one.
@end defun

@cindex most recently selected windows
The sequence of calls to @code{select-window} with a non-@code{nil}
@var{norecord} argument determines an ordering of windows by their
selection time.  The function @code{get-lru-window} can be used to
retrieve the least recently selected live window in this ordering, see
@ref{Cyclic Window Ordering}.

@defmac save-selected-window forms@dots{}
This macro records the selected frame, as well as the selected window
of each frame, executes @var{forms} in sequence, then restores the
earlier selected frame and windows.  It also saves and restores the
current buffer.  It returns the value of the last form in @var{forms}.

This macro does not save or restore anything about the sizes,
arrangement or contents of windows; therefore, if @var{forms} change
them, the change persists.  If the previously selected window of some
frame is no longer live at the time of exit from @var{forms}, that
frame's selected window is left alone.  If the previously selected
window is no longer live, then whatever window is selected at the end of
@var{forms} remains selected.  The current buffer is restored if and
only if it is still live when exiting @var{forms}.

This macro changes neither the ordering of recently selected windows nor
the buffer list.
@end defmac

@defmac with-selected-window window forms@dots{}
This macro selects @var{window}, executes @var{forms} in sequence, then
restores the previously selected window and current buffer.  The ordering
of recently selected windows and the buffer list remain unchanged unless
you deliberately change them within @var{forms}, for example, by calling
@code{select-window} with argument @var{norecord} @code{nil}.

The order of recently selected windows and the buffer list are not
changed by this macro.
@end defmac

@cindex frame selected window
@cindex window selected within frame
Above we explained that at any time, exactly one window on any frame is
selected within the frame.  The significance of this designation is that
selecting the frame also selects this window.  Conversely, selecting a
window for Emacs with @code{select-window} also makes that window
selected within its frame.

@defun frame-selected-window  &optional frame
This function returns the window on @var{frame} that is selected within
@var{frame}.  The optional argument @var{frame} must denote a live frame
and defaults to the selected one.
@end defun

@defun set-frame-selected-window frame window &optional norecord
This function sets the selected window of frame @var{frame} to
@var{window}.  The argument @var{frame} must denote a live frame and
defaults to the selected one.  If @var{frame} is the selected frame,
this also makes @var{window} the selected window.  The argument
@var{window} must denote a live window.  This function returns
@var{window}.

Optional argument @var{norecord} non-@code{nil} means to neither change
the list of most recently selected windows (@pxref{Selecting Windows})
nor the buffer list (@pxref{The Buffer List}).
@end defun

@node Cyclic Window Ordering
@section Cyclic Ordering of Windows
@cindex cyclic ordering of windows
@cindex ordering of windows, cyclic
@cindex window ordering, cyclic

When you use the command @kbd{C-x o} (@code{other-window}) to select
some other window, it moves through live windows in a specific order.
For any given configuration of windows, this order never varies.  It is
called the @dfn{cyclic ordering of windows}.

   For a particular frame, this ordering is determined by the window
tree of that frame, see @ref{Frames and Windows}.  More precisely, the
ordering is obtained by a depth-first traversal of the frame's window
tree supplemented, if requested, by the frame's minibuffer window.

   If there's just one live frame, the cyclic ordering is the ordering
for that frame.  Otherwise, the cyclic ordering is obtained by appending
the orderings for individual frames in order of the list of all live
frames, @ref{Finding All Frames}.  In any case, the ordering is made
``cyclic'' by having the last window precede the first window in the
ordering.

@defun next-window &optional window minibuf all-frames
@cindex minibuffer window, and @code{next-window}
This function returns the window following @var{window} in the cyclic
ordering of windows.  This is the window @kbd{C-x o} selects if typed
when @var{window} is selected.  The argument @var{window} must specify a
live window and defaults to the selected one.

The optional argument @var{minibuf} specifies whether minibuffer windows
shall be included in the cyclic ordering.  Normally, when @var{minibuf}
is @code{nil}, a minibuffer window is included only if it is currently
``active''; this matches the behavior of @kbd{C-x o}.  (Note that a
minibuffer window is active as long as its minibuffer is in use; see
@ref{Minibuffers}).

If @var{minibuf} is @code{t}, the cyclic ordering includes all
minibuffer windows.  If @var{minibuf} is neither @code{t} nor
@code{nil}, minibuffer windows are not included even if they are active.

The optional argument @var{all-frames} specifies which frames to
consider.  Here are the possible values and their meanings:

@itemize @bullet
@item @code{nil}
means consider all windows on @var{window}'s frame, plus the minibuffer
window used by that frame even if it lies in some other frame.  If the
minibuffer counts (as determined by @var{minibuf}), then all windows on
all frames that share that minibuffer count too.

@item @code{t}
means consider all windows on all existing frames.

@item @code{visible}
means consider all windows on all visible frames.  (To get useful
results, ensure that @var{window} is on a visible frame.)

@item 0
means consider all windows on all visible or iconified frames.

@item A frame
means consider all windows on that frame.

@item Anything else
means consider the windows on @var{window}'s frame, and no others.
@end itemize

This example assumes there are two windows, both displaying the
buffer @samp{windows.texi}:

@example
@group
(selected-window)
     @result{} #<window 56 on windows.texi>
@end group
@group
(next-window (selected-window))
     @result{} #<window 52 on windows.texi>
@end group
@group
(next-window (next-window (selected-window)))
     @result{} #<window 56 on windows.texi>
@end group
@end example
@end defun

@defun previous-window &optional window minibuf all-frames
This function returns the window preceding @var{window} in the cyclic
ordering of windows.  The other arguments specify which windows to
consider as in @code{next-window}.
@end defun

@deffn Command other-window count &optional all-frames
This function selects another window in the cyclic ordering of windows.
@var{count} specifies the number of windows to skip in the ordering,
starting with the selected window, before making the selection.  If
@var{count} is a positive number, it skips @var{count} windows forwards.
@var{count} negative means skip @minus{}@var{count} windows backwards.
If @var{count} is zero, it does not skip any window, thus re-selecting
the selected window.  In an interactive call, @var{count} is the numeric
prefix argument.

The optional argument @var{all-frames} has the same meaning as in
@code{next-window}, but the @var{minibuf} argument of @code{next-window}
is always effectively @code{nil}.  This function returns @code{nil}.
@end deffn

The following function returns a copy of the list of windows in the
cyclic odering.

@defun window-list-1 &optional window &optional minibuf &optional all_frames
This function returns a list of live windows.  The optional arguments
@var{minibuf} and @var{all-frames} specify the set of windows to include
in the list.  See the description of @code{next-window} for details.

The optional argument @var{window} specifies the first window to list
and defaults to the selected window.  If @var{window} is not on the list
of windows returned, some other window will be listed first but no error
is signalled.
@end defun

The functions described below use @code{window-list-1} for generating a
copy of the list of all relevant windows.  Hence, any change of the
window configuration that occurs while one of these functions is
executed is @emph{not} reflected in the list of windows investigated.

@defun walk-windows proc &optional minibuf all-frames
This function cycles through live windows.  It calls the function
@var{proc} once for each window, with the window as its sole argument.

The optional arguments @var{minibuf} and @var{all-frames} specify the
set of windows to include in the walk, see @code{next-window} above.  If
@var{all-frames} specifies a frame, the first window walked is the first
window on that frame as returned by @code{frame-first-window} and not
necessarily the selected window.

If @var{proc} changes the window configuration by splitting or deleting
windows, that change is not reflected in the set of windows walked.
That set is determined entirely by the set of live windows at the time
this function was invoked.
@end defun

The following function allows to determine whether a specific window is
the only live window.

@defun one-window-p &optional no-mini all-frames
This function returns non-@code{nil} if the selected window is the only
window.

The optional argument @var{no-mini}, if non-@code{nil}, means don't
count the minibuffer even if it is active; otherwise, the minibuffer
window is counted when it is active.  The optional argument
@var{all-frames} has the same meaning as for @code{next-window}, see
above.
@end defun

@cindex finding windows
  The following functions choose (but do not select) one of the windows
on the screen, offering various criteria for the choice.

@cindex least recently used window
@defun get-lru-window &optional all-frames dedicated
This function returns the window least recently ``used'' (that is,
selected).  If any full-width windows are present, it only considers
these.  The optional argument @var{all-frames} has the same meaning as
in @code{next-window}.

The selected window is returned if it is the only candidate.  A
minibuffer window is never a candidate.  A dedicated window
(@pxref{Dedicated Windows}) is never a candidate unless the optional
argument @var{dedicated} is non-@code{nil}.
@end defun

@cindex largest window
@defun get-largest-window &optional all-frames dedicated
This function returns the window with the largest area (height times
width).  If there are no side-by-side windows, then this is the window
with the most lines.  A minibuffer window is never a candidate.  A
dedicated window (@pxref{Dedicated Windows}) is never a candidate unless
the optional argument @var{dedicated} is non-@code{nil}.

If there are two candidate windows of the same size, this function
prefers the one that comes first in the cyclic ordering of windows,
starting from the selected window.

The optional argument @var{all-frames} specifies which set of windows to
consider as with @code{next-window}, see above.
@end defun

@cindex window that satisfies a predicate
@cindex conditional selection of windows
@defun get-window-with-predicate predicate &optional minibuf all-frames default
This function returns a window satisfying @var{predicate}.  It cycles
through all visible windows calling @var{predicate} on each one of them
with that window as its argument.  The function returns the first window
for which @var{predicate} returns a non-@code{nil} value; if that never
happens, it returns @var{default} (which defaults to @code{nil}).

The optional arguments @var{minibuf} and @var{all-frames} specify the
set of windows to investigate.  See the description of
@code{next-window} for details.
@end defun

@node Buffers and Windows
@section Buffers and Windows
@cindex examining windows
@cindex windows, controlling precisely
@cindex buffers, controlled in windows

To find out which buffer is displayed in a given window the following
function is used.

@defun window-buffer &optional window
This function returns the buffer that @var{window} is displaying.  The
argument @var{window} can be any window and defaults to the selected
one.  If @var{window} is an internal window, this function returns
@code{nil}.
@end defun

Next we describe the basic, low-level function to associate a window
with a buffer.  Higher-level functions like @code{display-buffer} try to
obey a number of user customizations regulating which windows are
supposed to display which buffers.  When writing an application,
programmers should therefore carefully evaluate whether they really need
the power of this function.

@defun set-window-buffer window buffer-or-name &optional keep-margins
This function makes @var{window} display @var{buffer-or-name} and
returns @code{nil}.  The argument @var{window} has to denote a live
window and defaults to the selected one.  The argument
@var{buffer-or-name} must specify a buffer or the name of an existing
buffer.

Normally, displaying @var{buffer-or-name} in @var{window} resets the
window's position, display margins, fringe widths, and scroll bar
settings based on the local variables of the specified buffer.  However,
if the optional argument @var{keep-margins} is non-@code{nil}, display
margins and fringe widths of @var{window} remain unchanged.
@xref{Fringes}.

@code{set-window-buffer} is the fundamental primitive for changing which
buffer is displayed in a window, and all ways of doing that call this
function.  Neither the selected window nor the current buffer are
changed by this function.

@code{set-window-buffer} signals an error when @var{window} is
@dfn{strongly} dedicated to its buffer (@pxref{Dedicated Windows}) and
does not already display @var{buffer-or-name}.

This function runs @code{window-scroll-functions} before running
@code{window-configuration-change-hook}, see @ref{Window Hooks}.
@end defun

@defvar buffer-display-count
This buffer-local variable records the number of times a buffer has been
displayed in a window.  It is incremented each time
@code{set-window-buffer} is called for the buffer.
@end defvar

@defvar buffer-display-time
This variable records the time at which a buffer was last made visible
in a window.  It is always local in each buffer; each time
@code{set-window-buffer} is called, it sets this variable to
@code{(current-time)} in the specified buffer (@pxref{Time of Day}).
When a buffer is first created, @code{buffer-display-time} starts out
with the value @code{nil}.
@end defvar

@defun get-buffer-window &optional buffer-or-name all-frames
This function returns a window displaying @var{buffer-or-name}, or
@code{nil} if there is none.  If there are several such windows, then
the function returns the first one in the cyclic ordering of windows,
starting from the selected window, @xref{Cyclic Window Ordering}.

The argument @var{BUFFER-OR-NAME} may be a buffer or a buffer name and
defaults to the current buffer.  The optional argument @var{all-frames}
specifies which windows to consider:

@itemize @bullet
@item
@code{nil} means consider windows on the selected frame.
@item
@code{t} means consider windows on all existing frames.
@item
@code{visible} means consider windows on all visible frames.
@item
0 means consider windows on all visible or iconified frames.
@item
A frame means consider windows on that frame only.
@end itemize

Observe that the behavior of @code{get-buffer-window} may differ from
that of @code{next-window} (@pxref{Cyclic Window Ordering}) when
@var{all-frames} equals @code{nil} or any value not listed here.
Perhaps we will change @code{get-buffer-window} in the future to make it
compatible with the other functions.
@end defun

@defun get-buffer-window-list &optional buffer-or-name minibuf all-frames
This function returns a list of all windows currently displaying
@var{buffer-or-name}.  The argument @var{buffer-or-name} may be a buffer
or the name of an existing buffer and defaults to the current buffer.

The two remaining arguments work like the same-named arguments of
@code{next-window} (@pxref{Cyclic Window Ordering}); they are @emph{not}
like the optional arguments of @code{get-buffer-window}.
@end defun

The following command removes a buffer from all windows showing it.

@deffn Command replace-buffer-in-windows &optional buffer-or-name
This function replaces @var{buffer-or-name} in all windows displaying it
with some other buffer.  It uses @code{other-buffer} (@pxref{Cyclic
Window Ordering}) to choose the other buffer.  In the usual applications
of this function, you don't care which other buffer is used; you just
want to make sure that @var{buffer-or-name} is no longer displayed.

The argument @var{buffer-or-name} may be a buffer or the name of an
existing buffer and defaults to the current buffer.

If a window displaying @var{buffer-or-name} is dedicated
(@pxref{Dedicated Windows}), and is not the only window on its frame,
that window is deleted.  If that window is the only window on its frame
and there are other frames left, the window's frame is deleted too.  If
there are no other frames left, some other buffer is displayed in that
window.

This function returns @code{nil}.
@end deffn

@node Switching Buffers
@section Switching to a Buffer in Some Window
@cindex switching to a buffer
@cindex popping to a buffer

In this section we describe convenient functions for switching to a
specified buffer in some window.  These functions can also split an
existing window in certain circumstances.  In any case, the window
chosen becomes the selected window and the buffer current.

   Do not use the functions in this section in order to make a buffer
current so that a Lisp program can access or modify it; they are too
drastic for that purpose, since they change the display of buffers in
windows, which would be gratuitous and surprise the user.  Instead, use
@code{set-buffer} and @code{save-current-buffer} (@pxref{Current
Buffer}), which designate buffers as current for programmed access
without affecting the display of buffers in windows.

@deffn Command switch-to-buffer buffer-or-name &optional norecord
This function makes the buffer specified by @var{buffer-or-name} current
and displays it in the selected window.  This means that a human can see
the buffer and subsequent keyboard commands will apply to it.  Contrast
this with @code{set-buffer}, which makes @var{buffer-or-name} the
current buffer but does not display it in the selected window; see
@ref{Current Buffer}.

If called interactively, it prompts for the buffer name using the
minibuffer.  The variable @code{confirm-nonexistent-file-or-buffer}
determines whether to request confirmation before creating a new buffer.

If @var{buffer-or-name} is @code{nil}, @code{switch-to-buffer} chooses a
buffer using @code{other-buffer}.  If @var{buffer-or-name} is a string
that does not identify an existing buffer, then a new buffer by that
name is created.  The major mode for the new buffer is set according to
the variable @code{major-mode}; see @ref{Auto Major Mode}.

When the selected window is the minibuffer window or is strongly
dedicated to its buffer (@pxref{Dedicated Windows}), this function calls
@code{pop-to-buffer} (see below) to display the buffer in some other
window.

Normally, the specified buffer is put at the front of the buffer list
(both the selected frame's buffer list and the frame-independent buffer
list, see @ref{The Buffer List}).  This affects the operation of
@code{other-buffer}.  However, if @var{norecord} is non-@code{nil}, this
is not done.  Also, if @var{norecord} is non-@code{nil}, the window
chosen for displaying the buffer is not automatically made the most
recently selected one.

@code{switch-to-buffer} is often used interactively, as the binding of
@kbd{C-x b}.  It is also used frequently in programs.  It returns the
buffer that it switched to.
@end deffn

The remaining functions described in this section are similar to
@code{switch-to-buffer}, except for the described features.

@deffn Command switch-to-buffer-other-window buffer-or-name &optional norecord
This command makes the buffer specified by @var{buffer-or-name} current
and displays it in a window not currently selected, by using the
function @code{pop-to-buffer} (see below).  It returns the buffer
switched to.

The currently selected window is absolutely never used to do the job.
If the selected window already displays @var{buffer-or-name}, then it
continues to do so, but another window is nonetheless found to display
it in as well.

The arguments @var{buffer-or-name} and @var{norecord} have the same
meaning as for @code{switch-to-buffer}.
@end deffn

@deffn Command switch-to-buffer-other-frame buffer-or-name &optional norecord
This command switches to buffer @var{buffer-or-name} in another frame.
It returns the buffer switched to.

The arguments @var{buffer-or-name} and @var{norecord} have the same
meaning as for @code{switch-to-buffer}.
@end deffn

@deffn Command pop-to-buffer buffer-or-name &optional other-window norecord
This command makes @var{buffer-or-name} the current buffer and switches
to it in some window, preferably not the window previously selected.
The ``popped-to'' window becomes the selected window.  Its frame is
given the X server's focus, if possible; see @ref{Input Focus}.  The
return value is the buffer that was switched to.

If either of the variables @code{display-buffer-reuse-frames} or
@code{pop-up-frames} is non-@code{nil}, @code{pop-to-buffer} looks for a
window in any visible frame already displaying the buffer; if there is
one, it selects and returns that window.  If no such window exists and
@code{pop-up-frames} is non-@code{nil}, it creates a new frame and
displays the buffer in it.  Otherwise, @code{pop-to-buffer} operates
entirely within the selected frame.  (If the selected frame has just a
minibuffer, @code{pop-to-buffer} operates within the most recently
selected frame that was not just a minibuffer.)

If the variable @code{pop-up-windows} is non-@code{nil}, windows may be
split to create a new window that is different from the original window.
For details, see @ref{Displaying Buffers}.

If @var{other-window} is non-@code{nil}, @code{pop-to-buffer} finds or
creates another window even if @var{buffer-or-name} is already visible
in the selected window.  Thus @var{buffer-or-name} could end up
displayed in two windows.  On the other hand, if @var{buffer-or-name} is
already displayed in the selected window and @var{other-window} is
@code{nil}, then the selected window is considered sufficient for
displaying @var{buffer-or-name}, so that nothing needs to be done.

All the variables that affect @code{display-buffer} affect
@code{pop-to-buffer} as well.  @xref{Displaying Buffers}.

The arguments @var{buffer-or-name} and @var{norecord} are handled as
with @code{switch-to-buffer}.
@end deffn

@node Displaying Buffers
@section Choosing a Window for Displaying a Buffer

This section describes the basic facility that chooses a window to
display a buffer in---@code{display-buffer}.  Higher-level commands and
functions like @code{pop-to-buffer} (@pxref{Switching Buffers}) and
@code{with-output-to-temp-buffer} (@pxref{Temporary Displays}), use this
as a subroutine.  Here we describe how @code{display-buffer} works and
and how to customize it.  We also describe a function which allows to
``quit'' the chosen window in a way that tries to restore the window to
its state before the buffer was displayed.

@deffn Command display-buffer buffer-or-name &optional not-this-window frame
This command makes the buffer specified by @var{buffer-or-name} appear
in some window, but it does not select that window and does not make the
buffer current.  The argument @var{buffer-or-name} must be a buffer or
the name of an existing buffer and defaults to the current buffer.

When called interactively, it prompts for a buffer name in the
minibuffer.  The variable `confirm-nonexistent-file-or-buffer'
determines whether to request confirmation before creating a new buffer.
The return value is the window chosen to display that buffer.

If the optional argument @var{not-this-window} is non-@code{nil}, this
means to display the specified buffer in a window other than the
selected one, even if it is already displayed in the selected window.
This can cause the buffer to appear in two windows at once.

If the optional argument @var{frame} is non-@code{nil}, it specifies
which frames to check when deciding whether the buffer is already
displayed.  If the buffer is already displayed in some window on one of
these frames, @code{display-buffer} will simply return that window.
Here are the possible values of @var{frame}:

@itemize @bullet
@item @code{nil}
means consider windows on the selected frame.
(Actually, the last non-minibuffer frame.)
@item @code{t}
means consider windows on all frames.
@item @code{visible}
means consider windows on all visible frames.
@item 0
means consider windows on all visible or iconified frames.
@item A frame
means consider windows on that frame only.
@end itemize
@end deffn

Precisely how @code{display-buffer} finds or creates a window depends on
the variables described below.

@defopt display-buffer-function
This variable is the most flexible way to customize the behavior of
@code{display-buffer}.  If it is non-@code{nil}, it should be a function
that @code{display-buffer} calls to do the work.  The function is called
with two arguments, the buffer to display and the @var{not-this-window}
argument of @code{display-buffer}.  It should choose or create a window,
display the specified buffer in it, and then return the window.
@end defopt

If @code{display-buffer-function} is @code{nil}, the selected window
already displays @var{buffer-or-name}, and @var{not-this-window} is
@code{nil}, @code{display-buffer} simply returns the selected window.
Otherwise, it consults the two options described next in order to decide
whether the buffer specified by @var{buffer-or-name} should appear in
the selected window.

@defopt same-window-buffer-names
A list of buffer names for buffers that should be displayed in the
selected window.  If the buffer's name is in this list, then
@code{display-buffer} displays the buffer in the selected window.
@end defopt

@defopt same-window-regexps
A list of regular expressions that specify buffers that should be
displayed in the selected window.  If the buffer's name matches any of
the regular expressions in this list, @code{display-buffer} displays the
buffer in the selected window.
@end defopt

If the selected window is not considered suitable for displaying
@var{buffer-or-name}, @code{display-buffer} will try to find another
window already displaying @var{buffer-or-name}.  It will do so, however,
if and only if either the variable @code{pop-up-frames} (see below) is
non-@code{nil} or the following option has been activated.

@defopt display-buffer-reuse-frames
If this variable is non-@code{nil}, @code{display-buffer} searches
visible and iconified frames for a window displaying
@var{buffer-or-name}.  If there is such a window, @code{display-buffer}
makes that window's frame visible, raises it if necessary, and returns
the window.
@end defopt

If there is no such window or both @var{display-buffer-reuse-frames} and
@var{pop-up-frames} are @code{nil}, @code{display-buffer} checks whether
@var{buffer-or-name} should be displayed specially according to the
options described next.

@defopt special-display-buffer-names
A list of buffer names identifying buffers that should be displayed
specially.  If the name of @var{buffer-or-name} is in this list,
@code{display-buffer} handles the buffer specially.  By default, special
display means to give the buffer a dedicated frame.

If an element is a list, instead of a string, then the @sc{car} of that
list is the buffer name, and the rest of that list says how to create
the frame.  There are two possibilities for the rest of that list (its
@sc{cdr}): It can be an alist, specifying frame parameters, or it can
contain a function and arguments to give to it.  (The function's first
argument is always the buffer to be displayed; the arguments from the
list come after that.)

For example:

@example
(("myfile" (minibuffer) (menu-bar-lines . 0)))
@end example

@noindent
specifies to display a buffer named @samp{myfile} in a dedicated frame
with specified @code{minibuffer} and @code{menu-bar-lines} parameters.

The list of frame parameters can also use the phony frame parameters
@code{same-frame} and @code{same-window}.  If the specified frame
parameters include @code{(same-window . @var{value})} and @var{value}
is non-@code{nil}, that means to display the buffer in the current
selected window.  Otherwise, if they include @code{(same-frame .
@var{value})} and @var{value} is non-@code{nil}, that means to display
the buffer in a new window in the currently selected frame.
@end defopt

@defopt special-display-regexps
A list of regular expressions specifying buffers that should be
displayed specially.  If the buffer's name matches any of the regular
expressions in this list, @code{display-buffer} handles the buffer
specially.  By default, special display means to give the buffer a
dedicated frame.

If an element is a list, instead of a string, then the @sc{car} of the
list is the regular expression, and the rest of the list says how to
create the frame.  See @code{special-display-buffer-names} above.
@end defopt

@defopt special-display-function
This variable holds the function to call to display a buffer specially.
It receives the buffer as an argument, and should return the window in
which it is displayed.  The default value of this variable is
@code{special-display-popup-frame}, see below.
@end defopt

@defun special-display-popup-frame buffer &optional args
This function tries to make @var{buffer} visible in a frame of its own.
If @var{buffer} is already displayed in some window, it makes that
window's frame visible and raises it.  Otherwise, it creates a frame
that is dedicated to @var{buffer}.  The return value is the window used
to display @var{buffer}.

If @var{args} is an alist, it specifies frame parameters for the new
frame.  If @var{args} is a list whose @sc{car} is a symbol, then
@code{(car @var{args})} is called as a function to actually create and
set up the frame; it is called with @var{buffer} as first argument, and
@code{(cdr @var{args})} as additional arguments.

This function always uses an existing window displaying @var{buffer},
whether or not it is in a frame of its own; but if you set up the above
variables in your init file, before @var{buffer} was created, then
presumably the window was previously made by this function.
@end defun

@defopt special-display-frame-alist
@anchor{Definition of special-display-frame-alist}
This variable holds frame parameters for
@code{special-display-popup-frame} to use when it creates a frame.
@end defopt

If @var{buffer-or-name} shall not be displayed specially,
@code{display-buffer} will try to pop up a new frame provided the option
described next permits that.

@defopt pop-up-frames
This variable specifies whether @code{display-buffer} should make new
frames.  If it is non-@code{nil}, @code{display-buffer} tries to locate
a window displaying @var{buffer-or-name} on any visible or iconified
frame, see above.  If no such window can be found, it makes a new frame,
unless the variable's value is @code{graphic-only} and the selected
frame is not on a graphic display.  @xref{Frames}, for more information.
@end defopt

@defopt pop-up-frame-function
This variable specifies how to make a new frame if @code{pop-up-frames}
is non-@code{nil}.

The value of this variable must be a function of no arguments.  When
@code{display-buffer} makes a new frame, it does so by calling that
function, which should return a frame.  The default value of this
variable is a function that creates a frame using the parameters
specified by @code{pop-up-frame-alist} described next.
@end defopt

@defopt pop-up-frame-alist
This variable holds an alist specifying frame parameters used by the
default value of @code{pop-up-frame-function} for making new frames.
@xref{Frame Parameters}, for more information about frame parameters.
@end defopt

If popping up a new frame is not possible, @code{display-buffer} will
try to split an existing window.

@defopt pop-up-windows
If this variable is non-@code{nil}, @code{display-buffer} is allowed to
make a new window on the selected frame.  (If the selected frame is a
minibuffer-only frame, @code{display-buffer} tries to make a new window
on another frame instead.)  If this variable is a non-empty list, that
list has to specify the windows @code{display-buffer} will consider for
splitting.  The following entries are supported.

@table @code
@item largest
The largest window, that is the window returned by
@code{get-largest-window}, see @ref{Cyclic Window Ordering}.

@item lru
The least recently used window as returned by @code{get-lru-window}, see
@ref{Cyclic Window Ordering}.

@item selected
The selected window on that frame as returned by
@code{frame-selected-window}, see @ref{Selecting Windows}.

@item root
The frame's root window as returned by @code{frame-root-window}, see
@ref{Frames and Windows}.
@end table

 The default value @code{t} stands for the list `(largest lru)'.  This
means that @code{display-buffer} will first try to split the largest
window and, if that fails, the least recently used window.  If this
variable is @code{nil}, @code{display-buffer} does not split any window.
@end defopt

@defopt split-window-preferred-function
This variable must specify a function with one argument, which is a
window.  The @code{display-buffer} routines will call this function with
one or more candidate windows when they look for a window to split.  The
function is expected to split that window and return the new window.  If
the function returns @code{nil}, this means that the argument window
cannot be split.

The default value of @code{split-window-preferred-function} is the
function @code{split-window-sensibly} described below.  If you customize
this option, bear in mind that @code{display-buffer} may call the
specified function once for each element of @code{pop-up-windows}, see
above.

This option affects the behavior of @code{display-buffer} only.  Other
functions like @code{split-window} and its relatives are @emph{not}
affected by it.
@end defopt

@defun split-window-sensibly window
This function takes a window as argument and tries to split that window
in a suitable way.  The two variables described next are useful for
tuning the behavior of this function.
@end defun

@defopt split-height-threshold
This variable specifies whether @code{split-window-sensibly} may split
windows vertically.  If it is an integer, @code{split-window-sensibly}
tries to split a window vertically only if it has at least this many
lines.  If the window has less lines, splitting fails, or the value of
this variable is @code{nil}, @code{split-window-sensibly} will try to
split the window horizontally, subject to restrictions of
@code{split-width-threshold} (see below).

If splitting horizontally fails too, and the window is the only window
on its frame, @code{split-window-sensibly} will try to split that window
vertically disregarding the value of this variable.  If this fails as
well, @code{split-window-sensibly} returns @code{nil}.

@code{split-window-sensibly} does not split a window vertically when
that window's height is fixed (@pxref{Window Sizes}).  Also, it splits a
window vertically only if the space taken up by that window can
accommodate two windows one above the other that are both at least
@code{window-min-height} lines tall.

Moreover, if the window that shall be split has a mode line,
@code{split-window-sensibly} does not split the window unless the new
window can accomodate a mode line too.  However, if the option
@code{window-splits} (@pxref{Splitting Windows}) equals @code{resize},
@code{split-window-sensibly} may split a window provided the resulting
windows can be embedded in a combination of windows.
@end defopt

@defopt split-width-threshold
This variable specifies whether @code{split-window-sensibly} may split
windows horizontally.  If it is an integer, @code{split-window-sensibly}
tries to split a window horizontally only if it has at least this many
columns.  If it is @code{nil}, @code{split-window-sensibly} will not
split the window horizontally.  (It still might split the window
vertically, though, see above.)

@code{split-window-sensibly} does not split a window horizontally if
that window's width is fixed (@pxref{Window Sizes}).  Also, it splits a
window horizontally only if the space that window takes up can
accommodate two windows side by side that are both at least
@code{window-min-width} columns wide.  Note, however, that if the option
@code{window-splits} (@pxref{Splitting Windows}) equals @code{resize},
@code{split-window-sensibly} will split the window provided it can embed
the emanating windows in a window combination.
@end defopt

If all options described so far fail to produce a suitable window,
@code{display-buffer} tries to reuse an existing window.  As a last
resort, it will try to display @var{buffer-or-name} on a separate frame.
In that case, the value of @code{pop-up-frames} is disregarded.

@defopt even-window-heights
This variable specifies whether @code{display-buffer} should even out
window heights if the buffer gets displayed in an existing window, above
or beneath another window.  If @code{even-window-heights} is
non-@code{nil}, the default, window heights will be evened out.  If
either of the involved window has fixed height (@pxref{Window Sizes}) or
@code{even-window-heights} is @code{nil}, window heights are left alone.
@end defopt

The command described next allows to quit the window chosen by
@code{display-buffer} and restore the previous state without undoing
changes to the window configuration that happend @emph{after}
@code{display-buffer} was called.  A more drastic solution is to save
the window configuration before calling @code{display-buffer} and
eventually restoring the saved configuration, @ref{Window
Configurations}.  That solution sometimes has the undesirable
side-effect that all changes that happened after the configuration was
saved are undone too.

@deffn Command quit-restore-window &optional window kill
This command ``quits'' @var{window} restoring its previous contents if
possible.  The argument @var{window} must be a live window and defaults
to the selected one.  This function always returns @code{nil}.

According to information stored in @var{window}'s @code{quit-restore}
window parameter (@pxref{Window Parameters}) this function performs one
of the following actions.

@itemize @bullet 
@item
Delete @var{window} and its frame.  This action is useful when
@var{window} was created on a standalone frame and there are other
frames left.

@item
Delete @var{window}.  This action is usually taken when @var{window} was
obtained by splitting some existing window.

@item
Restore the buffer previously displayed in @var{window}.  This action
is taken when @var{window} was temporarily reused for displaying some
other buffer.

@item
Make @var{window} display some other buffer.  This action is usually
taken when the three preceding ones are not applicable.
@end itemize

If its value was non-@code{nil}, this function resets @var{window}'s
@code{quit-restore} parameter to @code{nil}.

If the optional argument @var{kill} is non-@code{nil}, this means in
addition kill @var{window}'s buffer.  If @var{kill} is @code{nil}, this
simply puts @var{window}'s buffer at the end of the buffer list.
Interactively, @var{kill} is the prefix argument.
@end deffn

@node Dedicated Windows
@section Dedicated Windows
@cindex dedicated window

Functions for displaying a buffer can be told to not use specific
windows by marking these windows as @dfn{dedicated} to their buffers.
The function @code{display-buffer} (@pxref{Displaying Buffers}) never
uses a dedicated window for displaying another buffer in it.  The
functions @code{get-lru-window} and @code{get-largest-window}
(@pxref{Selecting Windows}) do not consider dedicated windows as
candidates when their @var{dedicated} argument is non-@code{nil}.  The
behavior of @code{set-window-buffer} (@pxref{Buffers and Windows}) with
respect to dedicated windows is slightly different, see below.

When @code{delete-windows-on} (@pxref{Deleting Windows}) wants to delete
a dedicated window and that window is the only window on its frame, it
deletes the window's frame too, provided there are other frames left.
The function @code{replace-buffer-in-windows} (@pxref{Displaying
Buffers}) tries to delete all dedicated windows showing its buffer
argument.  When such a window is the only window on its frame, that
frame is deleted, provided there are other frames left.  If there are no
more frames left, some other buffer is displayed in the window, and the
window is marked as non-dedicated.

When you kill a buffer (@pxref{Killing Buffers}) displayed in a
dedicated window, any such window usually gets deleted too, since
@code{kill-buffer} calls @code{replace-buffer-in-windows} for cleaning
up windows.  Burying a buffer (@pxref{The Buffer List}) deletes the
selected window if it is dedicated to that buffer.  If, however, that
window is the only window on its frame, @code{bury-buffer} displays
another buffer in it and iconifies the frame.

@defun window-dedicated-p &optional window
This function returns non-@code{nil} if @var{window} is dedicated to its
buffer and @code{nil} otherwise.  More precisely, the return value is
the value assigned by the last call of @code{set-window-dedicated-p} for
@var{window} or @code{nil} if that function was never called with
@var{window} as its argument.  The default for @var{window} is the
selected window.
@end defun

@defun set-window-dedicated-p window flag
This function marks @var{window} as dedicated to its buffer if
@var{flag} is non-@code{nil}, and non-dedicated otherwise.

As a special case, if @var{flag} is @code{t}, @var{window} becomes
@dfn{strongly} dedicated to its buffer.  @code{set-window-buffer}
signals an error when the window it acts upon is strongly dedicated to
its buffer and does not already display the buffer it is asked to
display.  Other functions do not treat @code{t} differently from any
non-@code{nil} value.
@end defun

@node Window Point
@section Windows and Point
@cindex window position
@cindex window point
@cindex position in window
@cindex point in window

Each window has its own value of point (@pxref{Point}), independent of
the value of point in other windows displaying the same buffer.  This
makes it useful to have multiple windows showing one buffer.

@itemize @bullet
@item
The window point is established when a window is first created; it is
initialized from the buffer's point, or from the window point of another
window opened on the buffer if such a window exists.

@item
Selecting a window sets the value of point in its buffer from the
window's value of point.  Conversely, deselecting a window sets the
window's value of point from that of the buffer.  Thus, when you switch
between windows that display a given buffer, the point value for the
selected window is in effect in the buffer, while the point values for
the other windows are stored in those windows.

@item
As long as the selected window displays the current buffer, the window's
point and the buffer's point always move together; they remain equal.
@end itemize

@cindex cursor
   As far as the user is concerned, point is where the cursor is, and
when the user switches to another buffer, the cursor jumps to the
position of point in that buffer.

@defun window-point &optional window
This function returns the current position of point in @var{window}.
For a nonselected window, this is the value point would have (in that
window's buffer) if that window were selected.  The default for
@var{window} is the selected window.

When @var{window} is the selected window and its buffer is also the
current buffer, the value returned is the same as point in that buffer.
Strictly speaking, it would be more correct to return the ``top-level''
value of point, outside of any @code{save-excursion} forms.  But that
value is hard to find.
@end defun

@defun set-window-point window position
This function positions point in @var{window} at position
@var{position} in @var{window}'s buffer.  It returns @var{position}.

If @var{window} is selected, and its buffer is current,
this simply does @code{goto-char}.
@end defun

@defvar window-point-insertion-type
This variable specifies the marker insertion type (@pxref{Marker
Insertion Types}) of @code{window-point}.  The default is @code{nil},
so @code{window-point} will stay behind text inserted there.
@end defvar

@node Window Start and End
@section The Window Start and End Positions
@cindex window start position

  Each window maintains a marker used to keep track of a buffer position
that specifies where in the buffer display should start.  This position
is called the @dfn{display-start} position of the window (or just the
@dfn{start}).  The character after this position is the one that appears
at the upper left corner of the window.  It is usually, but not
inevitably, at the beginning of a text line.

  After switching windows or buffers, and in some other cases, if the
window start is in the middle of a line, Emacs adjusts the window
start to the start of a line.  This prevents certain operations from
leaving the window start at a meaningless point within a line.  This
feature may interfere with testing some Lisp code by executing it
using the commands of Lisp mode, because they trigger this
readjustment.  To test such code, put it into a command and bind the
command to a key.

@defun window-start &optional window
@cindex window top line
This function returns the display-start position of window
@var{window}.  If @var{window} is @code{nil}, the selected window is
used.  For example,

@example
@group
(window-start)
     @result{} 7058
@end group
@end example

When you create a window, or display a different buffer in it, the
display-start position is set to a display-start position recently used
for the same buffer, or to @code{point-min} if the buffer doesn't have
any.

Redisplay updates the window-start position (if you have not specified
it explicitly since the previous redisplay)---to make sure point appears
on the screen.  Nothing except redisplay automatically changes the
window-start position; if you move point, do not expect the window-start
position to change in response until after the next redisplay.

For a realistic example of using @code{window-start}, see the
description of @code{count-lines}.  @xref{Definition of count-lines}.
@end defun

@cindex window end position
@defun window-end &optional window update
This function returns the position where display of its buffer ends in
@var{window}.  The default for @var{window} is the selected window.

Simply changing the buffer text or moving point does not update the
value that @code{window-end} returns.  The value is updated only when
Emacs redisplays and redisplay completes without being preempted.

If the last redisplay of @var{window} was preempted, and did not finish,
Emacs does not know the position of the end of display in that window.
In that case, this function returns @code{nil}.

If @var{update} is non-@code{nil}, @code{window-end} always returns an
up-to-date value for where display ends, based on the current
@code{window-start} value.  If a previously saved value of that position
is still valid, @code{window-end} returns that value; otherwise it
computes the correct value by scanning the buffer text.

Even if @var{update} is non-@code{nil}, @code{window-end} does not
attempt to scroll the display if point has moved off the screen, the
way real redisplay would do.  It does not alter the
@code{window-start} value.  In effect, it reports where the displayed
text will end if scrolling is not required.
@end defun

@defun set-window-start window position &optional noforce
This function sets the display-start position of @var{window} to
@var{position} in @var{window}'s buffer.  It returns @var{position}.

The display routines insist that the position of point be visible when a
buffer is displayed.  Normally, they change the display-start position
(that is, scroll the window) whenever necessary to make point visible.
However, if you specify the start position with this function using
@code{nil} for @var{noforce}, it means you want display to start at
@var{position} even if that would put the location of point off the
screen.  If this does place point off screen, the display routines move
point to the left margin on the middle line in the window.

For example, if point @w{is 1} and you set the start of the window
@w{to 37}, the start of the next line, point will be ``above'' the top
of the window.  The display routines will automatically move point if
it is still 1 when redisplay occurs.  Here is an example:

@example
@group
;; @r{Here is what @samp{foo} looks like before executing}
;;   @r{the @code{set-window-start} expression.}
@end group

@group
---------- Buffer: foo ----------
@point{}This is the contents of buffer foo.
2
3
4
5
6
---------- Buffer: foo ----------
@end group

@group
(set-window-start
 (selected-window)
 (save-excursion
   (goto-char 1)
   (forward-line 1)
   (point)))
@result{} 37
@end group

@group
;; @r{Here is what @samp{foo} looks like after executing}
;;   @r{the @code{set-window-start} expression.}
---------- Buffer: foo ----------
2
3
@point{}4
5
6
---------- Buffer: foo ----------
@end group
@end example

If @var{noforce} is non-@code{nil}, and @var{position} would place point
off screen at the next redisplay, then redisplay computes a new window-start
position that works well with point, and thus @var{position} is not used.
@end defun

@defun pos-visible-in-window-p &optional position window partially
This function returns non-@code{nil} if @var{position} is within the
range of text currently visible on the screen in @var{window}.  It
returns @code{nil} if @var{position} is scrolled vertically out of view.
Locations that are partially obscured are not considered visible unless
@var{partially} is non-@code{nil}.  The argument @var{position} defaults
to the current position of point in @var{window}; @var{window}, to the
selected window.  If @var{position} is @code{t}, that means to check the
last visible position in @var{window}.

The @code{pos-visible-in-window-p} function considers only vertical
scrolling.  If @var{position} is out of view only because @var{window}
has been scrolled horizontally, @code{pos-visible-in-window-p} returns
non-@code{nil} anyway.  @xref{Horizontal Scrolling}.

If @var{position} is visible, @code{pos-visible-in-window-p} returns
@code{t} if @var{partially} is @code{nil}; if @var{partially} is
non-@code{nil}, and the character following @var{position} is fully
visible, it returns a list of the form @code{(@var{x} @var{y})}, where
@var{x} and @var{y} are the pixel coordinates relative to the top left
corner of the window; otherwise it returns an extended list of the form
@code{(@var{x} @var{y} @var{rtop} @var{rbot} @var{rowh} @var{vpos})},
where @var{rtop} and @var{rbot} specify the number of off-window pixels
at the top and bottom of the row at @var{position}, @var{rowh} specifies
the visible height of that row, and @var{vpos} specifies the vertical
position (zero-based row number) of that row.

Here is an example:

@example
@group
;; @r{If point is off the screen now, recenter it now.}
(or (pos-visible-in-window-p
     (point) (selected-window))
    (recenter 0))
@end group
@end example
@end defun

@defun window-line-height &optional line window
This function returns the height of text line @var{line} in
@var{window}.  If @var{line} is one of @code{header-line} or
@code{mode-line}, @code{window-line-height} returns information about
the corresponding line of the window.  Otherwise, @var{line} is a text
line number starting from 0.  A negative number counts from the end of
the window.  The default for @var{line} is the current line in
@var{window}; the default for @var{window} is the selected window.

If the display is not up to date, @code{window-line-height} returns
@code{nil}.  In that case, @code{pos-visible-in-window-p} may be used
to obtain related information.

If there is no line corresponding to the specified @var{line},
@code{window-line-height} returns @code{nil}.  Otherwise, it returns
a list @code{(@var{height} @var{vpos} @var{ypos} @var{offbot})},
where @var{height} is the height in pixels of the visible part of the
line, @var{vpos} and @var{ypos} are the vertical position in lines and
pixels of the line relative to the top of the first text line, and
@var{offbot} is the number of off-window pixels at the bottom of the
text line.  If there are off-window pixels at the top of the (first)
text line, @var{ypos} is negative.
@end defun

@node Textual Scrolling
@section Textual Scrolling
@cindex textual scrolling
@cindex scrolling textually

  @dfn{Textual scrolling} means moving the text up or down through a
window.  It works by changing the value of the window's display-start
location.  It may also change the value of @code{window-point} to keep
point on the screen.

  Textual scrolling was formerly called ``vertical scrolling,'' but we
changed its name to distinguish it from the new vertical fractional
scrolling feature (@pxref{Vertical Scrolling}).

  In the commands @code{scroll-up} and @code{scroll-down}, the directions
``up'' and ``down'' refer to the motion of the text in the buffer at which
you are looking through the window.  Imagine that the text is
written on a long roll of paper and that the scrolling commands move the
paper up and down.  Thus, if you are looking at text in the middle of a
buffer and repeatedly call @code{scroll-down}, you will eventually see
the beginning of the buffer.

  Some people have urged that the opposite convention be used: they
imagine that the window moves over text that remains in place.  Then
``down'' commands would take you to the end of the buffer.  This view is
more consistent with the actual relationship between windows and the
text in the buffer, but it is less like what the user sees.  The
position of a window on the terminal does not move, and short scrolling
commands clearly move the text up or down on the screen.  We have chosen
names that fit the user's point of view.

  The textual scrolling functions (aside from
@code{scroll-other-window}) have unpredictable results if the current
buffer is different from the buffer that is displayed in the selected
window.  @xref{Current Buffer}.

  If the window contains a row which is taller than the height of the
window (for example in the presence of a large image), the scroll
functions will adjust the window's vertical scroll position to scroll
the partially visible row.  To disable this feature, Lisp code may bind
the variable @code{auto-window-vscroll} to @code{nil} (@pxref{Vertical
Scrolling}).

@deffn Command scroll-up &optional count
This function scrolls the text in the selected window upward
@var{count} lines.  If @var{count} is negative, scrolling is actually
downward.

If @var{count} is @code{nil} (or omitted), then the length of scroll
is @code{next-screen-context-lines} lines less than the usable height of
the window (not counting its mode line).

@code{scroll-up} returns @code{nil}, unless it gets an error
because it can't scroll any further.
@end deffn

@deffn Command scroll-down &optional count
This function scrolls the text in the selected window downward
@var{count} lines.  If @var{count} is negative, scrolling is actually
upward.

If @var{count} is omitted or @code{nil}, then the length of the scroll
is @code{next-screen-context-lines} lines less than the usable height of
the window (not counting its mode line).

@code{scroll-down} returns @code{nil}, unless it gets an error because
it can't scroll any further.
@end deffn

@deffn Command scroll-other-window &optional count
This function scrolls the text in another window upward @var{count}
lines.  Negative values of @var{count}, or @code{nil}, are handled
as in @code{scroll-up}.

You can specify which buffer to scroll by setting the variable
@code{other-window-scroll-buffer} to a buffer.  If that buffer isn't
already displayed, @code{scroll-other-window} displays it in some
window.

When the selected window is the minibuffer, the next window is normally
the one at the top left corner.  You can specify a different window to
scroll, when the minibuffer is selected, by setting the variable
@code{minibuffer-scroll-window}.  This variable has no effect when any
other window is selected.  When it is non-@code{nil} and the
minibuffer is selected, it takes precedence over
@code{other-window-scroll-buffer}.  @xref{Definition of
minibuffer-scroll-window}.

When the minibuffer is active, it is the next window if the selected
window is the one at the bottom right corner.  In this case,
@code{scroll-other-window} attempts to scroll the minibuffer.  If the
minibuffer contains just one line, it has nowhere to scroll to, so the
line reappears after the echo area momentarily displays the message
@samp{Beginning of buffer}.
@end deffn

@c Emacs 19 feature
@defvar other-window-scroll-buffer
If this variable is non-@code{nil}, it tells @code{scroll-other-window}
which buffer's window to scroll.
@end defvar

@defopt scroll-margin
This option specifies the size of the scroll margin---a minimum number
of lines between point and the top or bottom of a window.  Whenever
point gets within this many lines of the top or bottom of the window,
redisplay scrolls the text automatically (if possible) to move point
out of the margin, closer to the center of the window.
@end defopt

@defopt scroll-conservatively
This variable controls how scrolling is done automatically when point
moves off the screen (or into the scroll margin).  If the value is a
positive integer @var{n}, then redisplay scrolls the text up to
@var{n} lines in either direction, if that will bring point back into
proper view.  This behavior is called @dfn{conservative scrolling}.
Otherwise, scrolling happens in the usual way, under the control of
other variables such as @code{scroll-up-aggressively} and
@code{scroll-down-aggressively}.

The default value is zero, which means that conservative scrolling
never happens.
@end defopt

@defopt scroll-down-aggressively
The value of this variable should be either @code{nil} or a fraction
@var{f} between 0 and 1.  If it is a fraction, that specifies where on
the screen to put point when scrolling down.  More precisely, when a
window scrolls down because point is above the window start, the new
start position is chosen to put point @var{f} part of the window
height from the top.  The larger @var{f}, the more aggressive the
scrolling.

A value of @code{nil} is equivalent to .5, since its effect is to center
point.  This variable automatically becomes buffer-local when set in any
fashion.
@end defopt

@defopt scroll-up-aggressively
Likewise, for scrolling up.  The value, @var{f}, specifies how far
point should be placed from the bottom of the window; thus, as with
@code{scroll-up-aggressively}, a larger value scrolls more aggressively.
@end defopt

@defopt scroll-step
This variable is an older variant of @code{scroll-conservatively}.  The
difference is that it if its value is @var{n}, that permits scrolling
only by precisely @var{n} lines, not a smaller number.  This feature
does not work with @code{scroll-margin}.  The default value is zero.
@end defopt

@defopt scroll-preserve-screen-position
If this option is @code{t}, scrolling which would move the current
point position out of the window chooses the new position of point
so that the vertical position of the cursor is unchanged, if possible.

If it is non-@code{nil} and not @code{t}, then the scrolling functions
always preserve the vertical position of point, if possible.
@end defopt

@defopt next-screen-context-lines
The value of this variable is the number of lines of continuity to
retain when scrolling by full screens.  For example, @code{scroll-up}
with an argument of @code{nil} scrolls so that this many lines at the
bottom of the window appear instead at the top.  The default value is
@code{2}.
@end defopt

@deffn Command recenter &optional count
@cindex centering point
This function scrolls the text in the selected window so that point is
displayed at a specified vertical position within the window.  It does
not ``move point'' with respect to the text.

If @var{count} is a nonnegative number, that puts the line containing
point @var{count} lines down from the top of the window.  If
@var{count} is a negative number, then it counts upward from the
bottom of the window, so that @minus{}1 stands for the last usable
line in the window.  If @var{count} is a non-@code{nil} list, then it
stands for the line in the middle of the window.

If @var{count} is @code{nil}, @code{recenter} puts the line containing
point in the middle of the window, then clears and redisplays the entire
selected frame.

When @code{recenter} is called interactively, @var{count} is the raw
prefix argument.  Thus, typing @kbd{C-u} as the prefix sets the
@var{count} to a non-@code{nil} list, while typing @kbd{C-u 4} sets
@var{count} to 4, which positions the current line four lines from the
top.

With an argument of zero, @code{recenter} positions the current line at
the top of the window.  This action is so handy that some people make a
separate key binding to do this.  For example,

@example
@group
(defun line-to-top-of-window ()
  "Scroll current line to top of window.
Replaces three keystroke sequence C-u 0 C-l."
  (interactive)
  (recenter 0))

(global-set-key [kp-multiply] 'line-to-top-of-window)
@end group
@end example
@end deffn

@node Vertical Scrolling
@section Vertical Fractional Scrolling
@cindex vertical fractional scrolling
@cindex vertical scroll position

   @dfn{Vertical fractional scrolling} means shifting text in a window
up or down by a specified multiple or fraction of a line.  Each window
has a @dfn{vertical scroll position}, which is a number, never less than
zero.  It specifies how far to raise the contents of the window.
Raising the window contents generally makes all or part of some lines
disappear off the top, and all or part of some other lines appear at the
bottom.  The usual value is zero.

   The vertical scroll position is measured in units of the normal line
height, which is the height of the default font.  Thus, if the value is
.5, that means the window contents are scrolled up half the normal line
height.  If it is 3.3, that means the window contents are scrolled up
somewhat over three times the normal line height.

   What fraction of a line the vertical scrolling covers, or how many
lines, depends on what the lines contain.  A value of .5 could scroll a
line whose height is very short off the screen, while a value of 3.3
could scroll just part of the way through a tall line or an image.

@defun window-vscroll &optional window pixels-p
This function returns the current vertical scroll position of
@var{window}.  The default for @var{window} is the selected window.
If @var{pixels-p} is non-@code{nil}, the return value is measured in
pixels, rather than in units of the normal line height.

@example
@group
(window-vscroll)
     @result{} 0
@end group
@end example
@end defun

@defun set-window-vscroll window lines &optional pixels-p
This function sets @var{window}'s vertical scroll position to
@var{lines}.  If @var{window} is @code{nil}, the selected window is
used.  The argument @var{lines} should be zero or positive; if not, it
is taken as zero.


The actual vertical scroll position must always correspond
to an integral number of pixels, so the value you specify
is rounded accordingly.

The return value is the result of this rounding.

@example
@group
(set-window-vscroll (selected-window) 1.2)
     @result{} 1.13
@end group
@end example

If @var{pixels-p} is non-@code{nil}, @var{lines} specifies a number of
pixels.  In this case, the return value is @var{lines}.
@end defun

@defvar auto-window-vscroll
If this variable is non-@code{nil}, the line-move, scroll-up, and
scroll-down functions will automatically modify the vertical scroll
position to scroll through display rows that are taller than the height
of the window, for example in the presence of large images.
@end defvar

@node Horizontal Scrolling
@section Horizontal Scrolling
@cindex horizontal scrolling

  @dfn{Horizontal scrolling} means shifting the image in the window left
or right by a specified multiple of the normal character width.  Each
window has a @dfn{horizontal scroll position}, which is a number, never
less than zero.  It specifies how far to shift the contents left.
Shifting the window contents left generally makes all or part of some
characters disappear off the left, and all or part of some other
characters appear at the right.  The usual value is zero.

  The horizontal scroll position is measured in units of the normal
character width, which is the width of space in the default font.  Thus,
if the value is 5, that means the window contents are scrolled left by 5
times the normal character width.  How many characters actually
disappear off to the left depends on their width, and could vary from
line to line.

  Because we read from side to side in the ``inner loop,'' and from top
to bottom in the ``outer loop,'' the effect of horizontal scrolling is
not like that of textual or vertical scrolling.  Textual scrolling
involves selection of a portion of text to display, and vertical
scrolling moves the window contents contiguously; but horizontal
scrolling causes part of @emph{each line} to go off screen.

  Usually, no horizontal scrolling is in effect; then the leftmost
column is at the left edge of the window.  In this state, scrolling to
the right is meaningless, since there is no data to the left of the edge
to be revealed by it; so this is not allowed.  Scrolling to the left is
allowed; it scrolls the first columns of text off the edge of the window
and can reveal additional columns on the right that were truncated
before.  Once a window has a nonzero amount of leftward horizontal
scrolling, you can scroll it back to the right, but only so far as to
reduce the net horizontal scroll to zero.  There is no limit to how far
left you can scroll, but eventually all the text will disappear off the
left edge.

@vindex auto-hscroll-mode
  If @code{auto-hscroll-mode} is set, redisplay automatically alters
the horizontal scrolling of a window as necessary to ensure that point
is always visible.  However, you can still set the horizontal
scrolling value explicitly.  The value you specify serves as a lower
bound for automatic scrolling, i.e. automatic scrolling will not
scroll a window to a column less than the specified one.

@deffn Command scroll-left &optional count set-minimum
This function scrolls the selected window @var{count} columns to the
left (or to the right if @var{count} is negative).  The default
for @var{count} is the window width, minus 2.

The return value is the total amount of leftward horizontal scrolling in
effect after the change---just like the value returned by
@code{window-hscroll} (below).

Once you scroll a window as far right as it can go, back to its normal
position where the total leftward scrolling is zero, attempts to scroll
any farther right have no effect.

If @var{set-minimum} is non-@code{nil}, the new scroll amount becomes
the lower bound for automatic scrolling; that is, automatic scrolling
will not scroll a window to a column less than the value returned by
this function.  Interactive calls pass non-@code{nil} for
@var{set-minimum}.
@end deffn

@deffn Command scroll-right &optional count set-minimum
This function scrolls the selected window @var{count} columns to the
right (or to the left if @var{count} is negative).  The default
for @var{count} is the window width, minus 2.  Aside from the direction
of scrolling, this works just like @code{scroll-left}.
@end deffn

@defun window-hscroll &optional window
This function returns the total leftward horizontal scrolling of
@var{window}---the number of columns by which the text in @var{window}
is scrolled left past the left margin.  The default for
@var{window} is the selected window.

The return value is never negative.  It is zero when no horizontal
scrolling has been done in @var{window} (which is usually the case).


@example
@group
(window-hscroll)
     @result{} 0
@end group
@group
(scroll-left 5)
     @result{} 5
@end group
@group
(window-hscroll)
     @result{} 5
@end group
@end example
@end defun

@defun set-window-hscroll window columns
This function sets horizontal scrolling of @var{window}.  The value of
@var{columns} specifies the amount of scrolling, in terms of columns
from the left margin.  The argument @var{columns} should be zero or
positive; if not, it is taken as zero.  Fractional values of
@var{columns} are not supported at present.

Note that @code{set-window-hscroll} may appear not to work if you test
it by evaluating a call with @kbd{M-:} in a simple way.  What happens
is that the function sets the horizontal scroll value and returns, but
then redisplay adjusts the horizontal scrolling to make point visible,
and this overrides what the function did.  You can observe the
function's effect if you call it while point is sufficiently far from
the left margin that it will remain visible.

The value returned is @var{columns}.

@example
@group
(set-window-hscroll (selected-window) 10)
     @result{} 10
@end group
@end example
@end defun

   Here is how you can determine whether a given position @var{position}
is off the screen due to horizontal scrolling:

@example
@group
(defun hscroll-on-screen (window position)
  (save-excursion
    (goto-char position)
    (and
     (>= (- (current-column) (window-hscroll window)) 0)
     (< (- (current-column) (window-hscroll window))
        (window-width window)))))
@end group
@end example

@node Coordinates and Windows
@section Coordinates and Windows

This section describes how to relate edges and screen coordinates to
windows.

@defun window-edges &optional window
This function returns a list of the edge coordinates of @var{window}.
The default for @var{window} is the selected window.

The order of the list is @code{(@var{left} @var{top} @var{right}
@var{bottom})}, all elements relative to 0, 0 at the top left corner of
the frame.  The element @var{right} of the value is one more than the
rightmost column used by @var{window}, and @var{bottom} is one more than
the bottommost row used by @var{window} and its mode-line.

The edges include the space used by the window's scroll bar, display
margins, fringes, header line, and mode line, if it has them.  Also,
if the window has a neighbor on the right, its right edge value
includes the width of the separator line between the window and that
neighbor.  Since the width of the window does not include this
separator, the width does not usually equal the difference between the
right and left edges.
@end defun

@defun window-inside-edges &optional window
This is similar to @code{window-edges}, but the edge values
it returns include only the text area of the window.  They
do not include the header line, mode line, scroll bar or
vertical separator, fringes, or display margins.
@end defun

Here are the results obtained on a typical 24-line terminal with just
one window, with menu bar enabled:

@example
@group
(window-edges (selected-window))
     @result{} (0 1 80 23)
@end group
@group
(window-inside-edges (selected-window))
     @result{} (0 1 80 22)
@end group
@end example

@noindent
The bottom edge is at line 23 because the last line is the echo area.
The bottom inside edge is at line 22, which is the window's mode line.

If @var{window} is at the upper left corner of its frame, and there is
no menu bar, then @var{bottom} returned by @code{window-edges} is the
same as the value of @code{(window-total-height)}, @var{right} is the
same as the value of @code{(window-total-width)}, and @var{top} and
@var{left} are zero.  For example, the edges of the following window are
@w{@samp{0 0 8 5}}.  Assuming that the frame has more than 8 columns,
the last column of the window (column 7) holds a border rather than
text.  The last row (row 4) holds the mode line, shown here with
@samp{xxxxxxxxx}.

@example
@group
           0
           _______
        0 |       |
          |       |
          |       |
          |       |
          xxxxxxxxx  4

                  7
@end group
@end example

In the following example, let's suppose that the frame is 7
columns wide.  Then the edges of the left window are @w{@samp{0 0 4 3}}
and the edges of the right window are @w{@samp{4 0 7 3}}.
The inside edges of the left window are @w{@samp{0 0 3 2}},
and the inside edges of the right window are @w{@samp{4 0 7 2}},

@example
@group
           ___ ___
          |   |   |
          |   |   |
          xxxxxxxxx

           0  34  7
@end group
@end example

@defun window-pixel-edges &optional window
This function is like @code{window-edges} except that, on a graphical
display, the edge values are measured in pixels instead of in
character lines and columns.
@end defun

@defun window-inside-pixel-edges &optional window
This function is like @code{window-inside-edges} except that, on a
graphical display, the edge values are measured in pixels instead of
in character lines and columns.
@end defun

@defun window-at x y &optional frame
This function returns the window containing the specified cursor
position in the frame @var{frame}.  The coordinates @var{x} and @var{y}
are measured in characters and count from the top left corner of the
frame.  If they are out of range, @code{window-at} returns @code{nil}.

If you omit @var{frame}, the selected frame is used.
@end defun

@defun coordinates-in-window-p coordinates window
This function checks whether a particular frame position falls within
the window @var{window}.

The argument @var{coordinates} is a cons cell of the form @code{(@var{x}
. @var{y})}.  The coordinates @var{x} and @var{y} are measured in
characters, and count from the top left corner of the screen or frame.

The value returned by @code{coordinates-in-window-p} is non-@code{nil}
if the coordinates are inside @var{window}.  The value also indicates
what part of the window the position is in, as follows:

@table @code
@item (@var{relx} . @var{rely})
The coordinates are inside @var{window}.  The numbers @var{relx} and
@var{rely} are the equivalent window-relative coordinates for the
specified position, counting from 0 at the top left corner of the
window.

@item mode-line
The coordinates are in the mode line of @var{window}.

@item header-line
The coordinates are in the header line of @var{window}.

@item vertical-line
The coordinates are in the vertical line between @var{window} and its
neighbor to the right.  This value occurs only if the window doesn't
have a scroll bar; positions in a scroll bar are considered outside the
window for these purposes.

@item left-fringe
@itemx right-fringe
The coordinates are in the left or right fringe of the window.

@item left-margin
@itemx right-margin
The coordinates are in the left or right margin of the window.

@item nil
The coordinates are not in any part of @var{window}.
@end table

The function @code{coordinates-in-window-p} does not require a frame as
argument because it always uses the frame that @var{window} is on.
@end defun

@node Window Configurations
@section Window Configurations
@cindex window configurations
@cindex saving window information

  A @dfn{window configuration} records the entire layout of one
frame---all windows, their sizes, which buffers they contain, how those
buffers are scrolled, and their values of point and the mark; also their
fringes, margins, and scroll bar settings.  It also includes the value
of @code{minibuffer-scroll-window}.  As a special exception, the window
configuration does not record the value of point in the selected window
for the current buffer.

  You can bring back an entire frame layout by restoring a previously
saved window configuration.  If you want to record the layout of all
frames instead of just one, use a frame configuration instead of a
window configuration; see @ref{Frame Configurations}.

@defun current-window-configuration &optional frame
This function returns a new object representing @var{frame}'s current
window configuration.  The default for @var{frame} is the selected
frame.
@end defun

@defun set-window-configuration configuration
This function restores the configuration of windows and buffers as
specified by @var{configuration}, for the frame that @var{configuration}
was created for.

The argument @var{configuration} must be a value that was previously
returned by @code{current-window-configuration}.  The configuration is
restored in the frame from which @var{configuration} was made, whether
that frame is selected or not.  This always counts as a window size
change and triggers execution of the @code{window-size-change-functions}
(@pxref{Window Hooks}), because @code{set-window-configuration} doesn't
know how to tell whether the new configuration actually differs from the
old one.

If the frame which @var{configuration} was saved from is dead, all this
function does is restore the three variables @code{window-min-height},
@code{window-min-width} and @code{minibuffer-scroll-window}. In this
case, the function returns @code{nil}.  Otherwise, it returns @code{t}.

Here is a way of using this function to get the same effect
as @code{save-window-excursion}:

@example
@group
(let ((config (current-window-configuration)))
  (unwind-protect
      (progn (split-window-vertically nil)
             @dots{})
    (set-window-configuration config)))
@end group
@end example
@end defun

@defspec save-window-excursion forms@dots{}
This special form records the window configuration, executes @var{forms}
in sequence, then restores the earlier window configuration.  The window
configuration includes, for each window, the value of point and the
portion of the buffer that is visible.  It also includes the choice of
selected window.  However, it does not include the value of point in
the current buffer; use @code{save-excursion} also, if you wish to
preserve that.

Don't use this construct when @code{save-selected-window} is sufficient.

Exit from @code{save-window-excursion} always triggers execution of
@code{window-size-change-functions}.  (It doesn't know how to tell
whether the restored configuration actually differs from the one in
effect at the end of the @var{forms}.)

The return value is the value of the final form in @var{forms}.
For example:

@example
@group
(split-window)
     @result{} #<window 25 on control.texi>
@end group
@group
(setq w (selected-window))
     @result{} #<window 19 on control.texi>
@end group
@group
(save-window-excursion
  (delete-other-windows w)
  (switch-to-buffer "foo")
  'do-something)
     @result{} do-something
     ;; @r{The screen is now split again.}
@end group
@end example
@end defspec

@defun window-configuration-p object
This function returns @code{t} if @var{object} is a window configuration.
@end defun

@defun compare-window-configurations config1 config2
This function compares two window configurations as regards the
structure of windows, but ignores the values of point and mark and the
saved scrolling positions---it can return @code{t} even if those
aspects differ.

The function @code{equal} can also compare two window configurations; it
regards configurations as unequal if they differ in any respect, even a
saved point or mark.
@end defun

@defun window-configuration-frame config
This function returns the frame for which the window configuration
@var{config} was made.
@end defun

  Other primitives to look inside of window configurations would make
sense, but are not implemented because we did not need them.  See the
file @file{winner.el} for some more operations on windows
configurations.

@node Window Parameters
@section Window Parameters
@cindex window parameters

This section describes how window parameters can be used to associate
additional information with windows.

@defun window-parameter window parameter
This function returns @var{window}'s value for @var{parameter}.  The
default for @var{window} is the selected window.  If @var{window} has no
setting for @var{parameter}, this function returns @code{nil}.
@end defun

@defun window-parameters &optional window
This function returns all parameters of @var{window} and their values.
The default for @var{window} is the selected window.  The return value,
if non-@code{nil} is an association list whose elements have the form
@code{(@var{parameter} . @var{value})}.
@end defun

@defun set-window-parameter window parameter value
This function sets @var{window}'s value of @var{parameter} to
@var{value} and returns @var{value}.  The default for @var{window}
is the selected window.
@end defun

Some functions, notably @code{split-window}, @code{delete-window}, and
@code{delete-other-windows} behave specially when their @var{window}
argument has a parameter set.  The special behavior consists of a
pre-operation step and a post-operation step.

In the @dfn{pre-operation step}, the value of the parameter is analyzed
and, if its value prescribes some special action, that action is
executed.  For example, the pre-operation step of @code{delete-window}
when invoked on the main window of a compound window (@pxref{Compound
Windows}) calls @code{delete-window} with the root window of the
compound window as argument instead.

In the @dfn{post-operation step}, the parameters of all windows forming
the new configuration are adjusted.  For example, @code{split-window}
when invoked on a main window of a window group (@pxref{Window Groups}),
sets in this step the corresponding parameter of the new window.

You can override that special behavior by binding the following variable
to a non-@code{nil} value:

@defvar ignore-window-parameters
If this variable is non-@code{nil}, some standard functions ignore
window parameters.  The functions currently affected by this are
@code{split-window}, @code{delete-window}, @code{delete-other-windows}
and @code{other-window}.

When this variable equals @code{pre}, the pre-operation step is skipped
but the post-operation step is executed.  When this variable equals
@code{post}, the pre-operation step is executed and thee post-operation
step is skipped.

The value @code{t} means pre- and post-operation steps are skipped.
Currently any other non-@code{nil} value is handled like @code{t}.

An application can bind this variable to a non-@code{nil} value around
calls to these functions.  If it does so and the value is not
@code{pre}, the application is fully responsible for correctly setting
the parameters of all remaining windows after the function exited.
@end defvar

Window parameters are mainly used for implementing composite windows,
@xref{Composite Windows}.  In particular, the @code{compound},
@code{group} and @code{composite} parameters are reserved for that
purpose.

The @code{quit-restore} parameter tells how to proceed with a window
when the user ``quits'' it by invoking @code{quit-restore-window}, see
@ref{Displaying Buffers}.  The following non-@code{nil} values of this
parameter have a special meaning.

@table @asis
@item @code{t}
This means to delete the associated window.  By default, @code{t} is
used for a ``temporary'' window that was obtained by splitting an
existing window.

@item @code{frame}
This means to delete the associated window's frame.  This value
indicates that the associated windows was obtained by popping up a new
frame showing just this window.  If the window is no more needed, it
should be deleted together with the containing frame.

@item A list
This option is useful when the associated window was borrowed to
temporarily display some buffer and quitting shall ``restore'' the
previous contents of the window.  The first three elements of the list
must specify a buffer, a window start position, and a window point.
Quitting the window will then try to display the indicated buffer with
the given start position and point in that window.

The fourth element, if non-@code{nil}, must denote a live buffer.  If
specified, quitting will restore the previous window contents if and
only if the buffer shown in the window is the buffer named by this
element.

The fifth element, if non-@code{nil}, should specify the desired height
of the window when its buffer is restored.  This value is applied if the
buffer temporarily shown in the window was in
@code{temp-buffer-resize-mode} to restore the original height of the
window.
@end table

@node Composite Windows
@section Composite Windows
@cindex composite windows

A @dfn{composite window} is a rectangular frame area, typically composed
of one or more so-called support windows grouped around one or more
so-called main windows.  Some applications allow degenerate composite
windows consisting of one live window only.  Currently, two types of
composite windows are supported: Compound windows (@pxref{Compound
Windows}) and window groups (@pxref{Window Groups}).

@cindex composite root window
Each composite window has one and only one composite root window.  That
root window is usually an internal window (@pxref{Frames and Windows})
but may be a live window in the degenerate case where the composite
window is a live window.  All other windows of a composite window are
subwindows of the composite root window.

@defun composite-root-window-p window
This function return non-@code{nil} if @var{window} is the root window
of a composite window.  The return value is the type of that composite
window, currently either @code{compound} or @code{group}.
@end defun

@defun composite-window-p window
This function returns non-@code{nil} if @var{window} is a subwindow of a
composite window.  The return value is the value of the @code{composite}
window parameter (@pxref{Window Parameters}) of @var{window}.

Note that a composite root window that is not part of a composite window
does not have its @code{composite} window parameter set.  That parameter
is reserved for subwindows of a composite window only.  A root window is
not a subwindow of the composite window rooted at it.
@end defun

@cindex main window
Each composite window must contain at least one @dfn{main window}.  A
main window can be either a live window or an internal window.  Live
main windows are the places where ``normal'' editing activities take
place.  An internal main window is either a window whose subwindows are
all main windows of the same composite window, or the root window of
another composite window.

@defun composite-main-window-p window
Ths function returns @code{t} if @var{window} is a main window of a
composite window.
@end defun

@cindex support window
Composite windows may also contain an arbitrary number of @dfn{support
windows}.  A support window can be either a live window or an internal
window.  Live support windows usually supply information like lists of
files, buffers, tags, or bookmarks, a toolbar, tabs, or compiler and
system messages.  An internal support window is either a window whose
subwindows are all support windows of the same composite window, or the
root window of another composite window.

@defun composite-support-window-p window
Ths function returns @code{t} if @var{window} is a support window of a
composite window.
@end defun

For technical reasons, composite windows may contain internal subwindows
that are neither main nor support windows.  These windows are supposed
to have at least one main and one support window among their child
windows.  The functions @code{composite-main-window-p} and
@code{composite-support-window-p} return @code{nil} for such windows.

Composite windows are implemented with the help of three reserved window
parameters, see @ref{Window Parameters}.  Applications should never use
these parameters for any other purposes than the ones described below.

@table @asis
@item @code{compound}
If non-@code{nil}, this parameter designates the associated window as
the root window of a compound window, see @ref{Compound Windows}.

@item @code{group}
If the value of this parameter is non-@code{nil}, the associated window
is the root window of a window group, see @ref{Window Groups}.

@item @code{composite}
If this parameter is non-@code{nil}, the associated window is a
subwindow of a composite window.  The value must be a cons cell whose
@sc{car} denotes the @dfn{type} of the composite window, either
@code{compound} or @code{group}.

The @sc{cdr} denotes the @dfn{role} of the associated window within the
composite window and should be either @code{main}, @code{support} or
@code{t}.  The value @code{t} usually designates the associated window
as an internal window with at least one main and one support window
among its children.
@end table

For any subwindow @sc{w} of a composite window there has to exist a
unique path from @sc{w} to the root window @sc{r} of the composite
window such that the following property holds invariantly:

@enumerate
@item
The parent window @sc{p} of @sc{w} is either @sc{r} or a subwindow of
@sc{r}.

@item
The types of @sc{w} and @sc{p} must match: This means that if @sc{p}
is @sc{r} then either the type of @sc{w} must be @code{compound} and
the @code{compound} parameter of @sc{r} must be @code{t} or the type of
@sc{w} must be @code{group} and the @code{group} parameter of @sc{r}
must be @code{t}.

@item
If @sc{p} is not @sc{r} either the roles of @sc{w} and @sc{p} are
the same or @sc{p} is neither a main nor a support window.
@end enumerate

Violating this property usually breaks subsequent operations on the
composite window.

@defun composite-root-window window
This function returns the root window of the composite window that
contains @var{window} as a subwindow.  It returns @code{nil} if
@var{window} is not a subwindow of a composite window or the path from
@var{window} to the root of the composite window is broken.

When @var{window} is a subwindow of two or more composite windows, this
function returns the ``innermost'' root window, that is the first root
window found following the path from @var{window} to the root window of
its frame.
@end defun

@cindex major window
Usually, each composite window has one @dfn{major window} comprising all
other main windows of the composite window.  Any composite window should
have only one major window to make sure that functions on its component
windows behave ``as intended''.  The major window can be retrieved via
the following function:

@defun composite-major-window window
This function returns the major window of the composite window
@var{window} belongs to.  The major window is the last main or root
window found by following the path from @var{window} to the root of the
composite window @var{window} belongs to.

This function returns a meaningful result if and only if @var{window} is
a main window.
@end defun

Note also the following aspects of composite windows:

@itemize @bullet
@item
In degenerate cases one and the same window can be the root window of a
compound window and a window group.

@item
Composite windows can be nested.  This means that the root window of a
composite window can also be a subwindow of another composite window.
@end itemize

Uusally, the fact that a window is a subwindow of a composite window
changes the semantics of a number of functions called with that window
as argument.  See @ref{Compound Windows} for a list of functions whose
semantics change in compound windows.  See @ref{Window Groups} for a
corresponding list of functions that behave specially in window groups.

You can override the special behavior of any of these functions for a
particular window in one of two ways:

@itemize @bullet
@item
Set a window parameter denoting the function in question to @code{t}.
This makes the function ``behave as usual''.  For example

@smallexample
(set-window-parameter W 'split-window t)
@end smallexample

will cause @code{split-window} split the window @sc{w} as if @sc{w}
did not have any parameters.

@item
Specify the function to be called instead.  For example

@smallexample
(set-window-parameter W 'split-window 'my-split-window)
@end smallexample

will have @code{split-window} call the function @code{my-split-window}
with the original arguments to do the real work.  As a special case

@smallexample
(set-window-parameter W 'split-window 'ignore)
@end smallexample

will do nothing and return @code{nil}.

@item
Bind the value of @var{ignore-window-parameters} (@pxref{Window
Parameters}) to non-@code{nil} around a call to the function.
@end itemize

The command @code{other-window} usually does not select a support
window.  You can override this behavior by specifying

@smallexample
(set-window-parameter W 'maybe-other-window t)
@end smallexample

in which case @code{other-window} can select @sc{w} just like any other
window.  To specify that a main window does not get selected by
@code{other-window}, set its @code{no-other-window} parameter to
@code{t} as

@smallexample
(set-window-parameter W 'no-other-window t)
@end smallexample

Creating a new support window can be tricky.  The following function
should handle this.

@defun make-support-window window support &optional size horizontal
This function adds a support window of type @var{support} to
@var{window}.  The argument @var{window} must specify either a root
window or a subwindow of a composite window.  The argument @var{window}
must be one of @code{compound} or @code{group}.  The optional arguments
@var{SIZE} and @var{HORIZONTAL} are as for @code{split-window}.  The
return value is the new support window.

This function behaves like @code{split-window} but makes sure that the
parameters of all involved windows are set correctly.  In particular,
the new leaf window becomes a support window of the composite window.
@end defun


@node Compound Windows
@section Compound Windows
@cindex compound windows

A @dfn{compound window} is a composite window (@pxref{Composite
Windows}) built from two or more subwindows.  For any subwindow of a
compound window the semantics of a number of operations usually changes
in the sense that the operation is suitably applied to the entire
compound window instead.

   One typical use of a compound window is that of providing a sidebar
(like the speedbar) attached to a single ``main'' window.  Splitting the
main window vertically then guarantees that the new window appears below
(or above) the compound window thus not disrupting the relationship
between the sidebar and the main window.  Another use of compound
windows is that of a support window displaying a toolbar or tabs above a
main window.  In this case splitting the main window horizontally will
not break the relationship between the supporting and the main window.

   Compound windows must have at least two subwindows.  When
@code{delete-window} deletes a subwindow of a compound window and there
is only one more subwindow left, the compound window is dissolved
automatically and ceases to have any impact on subsequent operations on
the last remaining subwindow.  Apart from this restriction a compound
window may have any number of subwindows.  Deleting the last main window
of a compound window deletes the entire compound window instead (recall
that a composite window must have at least one main subwindow).

   Application programs are supposed to preserve the types assigned to
members of compound windows.  If they don't, they risk to break the
semantics of operations on the compound window.  Note also that any
subwindow of a compound window can be the root of another composite
window since the latter can be nested.

   In addition to the functions giving meaningful results for any
composite window (@pxref{Composite Windows}) the following functions
have been designed specifically to operate on a subwindow of a compound
window.

@defun compound-window-p window
This function returns non-@code{nil} if @var{window} is a subwindow of a
compound window.
@end defun

@defun compound-main-window-p window
This function returns non-@code{nil} if @var{window} is a main window of
a compound window.
@end defun

A compound window can be created with the following function:

@defun make-compound-window &optional window main size horizontal
This functions behaves like @code{split-window} (@pxref{Splitting
Windows}) with the additional twist that it makes @var{window} the main
window of a new compound window.  For this purpose, it creates a new
internal window with @var{window} and a new leaf window as its only
children.  @var{window} must be a leaf window and defaults to the
selected window.

If the optional argument @var{main} is non-@code{nil}, this means the
new leaf window becomes a main window.  Argument @var{main} @code{nil}
or not provided means the new leaf window becomes a support window.  The
original window @var{window} always becomes a main window.

The optional arguments @var{size} and @var{horizontal} are as for
@code{split-window}.  The return value is the new leaf window.
@end defun

Alternatively, a compound window can be constructed ``manually'' by
splitting some live window and setting the @code{root} and
@code{composite} parameters of the involved windows.  Look at how
@code{make-compound-window} sets these parameters for an example.

Currently, the semantics of the following commands and functions change
when their window argument is a member of a compound window:

@table @asis
@item @code{split-window} (@pxref{Splitting Windows})
When @var{window} is a component of a compound window,
@code{split-window} is invoked with the root window of the compound
window as argument instead.

@item @code{delete-window} (@pxref{Deleting Windows})
When @var{window} is a component of a compound window,
@code{delete-window} deletes the entire compound window instead.  If the
root window of the compound window is the root window of its containing
frame, or a support window or the only main window of a window group
(@pxref{Window Groups}) an error is signalled.

@item @code{delete-other-windows} (@pxref{Deleting Windows})
When @var{window} belongs to a compound window,
@code{delete-other-windows} makes the compound window fill its frame or,
if present, the innermost enclosing major window of a window group, see
@ref{Window Groups}.  If the root window of the compound window is the
root window of its containing frame, or a support window or the only
main window of a window group (@pxref{Window Groups}) nothing is done.
@end table

@node Window Groups
@section Window Groups
@cindex window groups

A @dfn{window group} is a composite window (@pxref{Composite Windows})
built from one or more subwindows.  The main application area of window
groups is in the implementation of Integrated Development Environments
(IDEs) where a rectangular subarea of a frame constitutes the editing
environment proper.  The remaining windows are used for displaying
supporting information and are not intended for editing.

Each window group must contain at least one main window which must be
either live or an internal window which should comprise all other main
windows of the group.  Note that the latter restriction is not checked
by the routines operating on window groups but it's better if
application preserve it since some operations inherently rely on it.

Usually, the root window of a window group is also the root window of
the containing frame (@pxref{Frames and Windows}).  Note, however, that
window groups (and compound windows) can be arbitrarily nested.

@defun group-window-p window
This function returns non-@code{nil} if @var{window} is a subwindow of a
window group.
@end defun

@defun group-window-main-p window
This function returns non-@code{nil} if @var{window} is a main window of
a window group.
@end defun

@defun group-root-window window
This function returns the root window of the window group @var{window}
belongs to.  If @var{window} is part of a compound window, it returns
the root window of the group the root of the compound window belongs
too.
@end defun

You can create a new window group with the following function:

@defun make-window-group &optional window
This functions makes @var{window} the main and root window of a new
window group.  The argument @var{window} must be a live window and
defaults to the selected one.  This function returns @var{window}.
@end defun

Alternatively, you can construct a window group ``manually'' by
appropriately setting the @code{root} parameter of any live window.

Currently, the semantics of the following commands and functions change
when their window argument is a member of a window group:

@table @asis
@item @code{split-window} (@pxref{Splitting Windows})
@code{split-window} is allowed to split main windows of a window group
only.  It will signal an error when invoked with a support window as
argument.

@item @code{delete-window} (@pxref{Deleting Windows})
@code{delete-window} is allowed to delete a main window of a window
group only.  It will signal an error when invoked with a support window
or the last main window of the group as argument

If a window group contains two disjoint main windows that are not
subwindows of another main window of the group, @code{delete-window} may
signal an error even if the window group contains other main windows.

@item @code{delete-other-windows} (@pxref{Deleting Windows})
When @code{delete-other-windows} is invoked with a main window of a
window group as argument, it will delete all main windows of that group
that are neither the argument window itself nor a subwindow of the
argument window.  Support windows are not affected by this operation.
An error is signalled when @code{delete-other-windows} is invoked with a
support window as its argument.

If a window group contains two disjoint main windows that are not
subwindows of another main window of the group,
@code{delete-other-windows} will not be able to remove all main windows
but the argument window and its subwindows.
@end table

@node Window Hooks
@section Hooks for Window Scrolling and Changes
@cindex hooks for window operations

This section describes how a Lisp program can take action whenever a
window displays a different part of its buffer or a different buffer.
There are three actions that can change this: scrolling the window,
switching buffers in the window, and changing the size of the window.
The first two actions run @code{window-scroll-functions}; the last runs
@code{window-size-change-functions}.

@defvar window-scroll-functions
This variable holds a list of functions that Emacs should call before
redisplaying a window with scrolling.  Displaying a different buffer in
the window also runs these functions.

This variable is not a normal hook, because each function is called with
two arguments: the window, and its new display-start position.

These functions must be careful in using @code{window-end}
(@pxref{Window Start and End}); if you need an up-to-date value, you
must use the @var{update} argument to ensure you get it.

@strong{Warning:} don't use this feature to alter the way the window
is scrolled.  It's not designed for that, and such use probably won't
work.
@end defvar

@defvar window-size-change-functions
This variable holds a list of functions to be called if the size of any
window changes for any reason.  The functions are called just once per
redisplay, and just once for each frame on which size changes have
occurred.

Each function receives the frame as its sole argument.  There is no
direct way to find out which windows on that frame have changed size, or
precisely how.  However, if a size-change function records, at each
call, the existing windows and their sizes, it can also compare the
present sizes and the previous sizes.

Creating or deleting windows counts as a size change, and therefore
causes these functions to be called.  Changing the frame size also
counts, because it changes the sizes of the existing windows.

It is not a good idea to use @code{save-window-excursion} (@pxref{Window
Configurations}) in these functions, because that always counts as a
size change, and it would cause these functions to be called over and
over.  In most cases, @code{save-selected-window} (@pxref{Selecting
Windows}) is what you need here.
@end defvar

@defvar window-configuration-change-hook
A normal hook that is run every time you change the window configuration
of an existing frame.  This includes splitting or deleting windows,
changing the sizes of windows, or displaying a different buffer in a
window.

The buffer-local part of this hook is run once per each window on the
affected frame, with the relevant window selected and its buffer
current.  The global part is run once for the modified frame, with that
frame selected.
@end defvar

  In addition, you can use @code{jit-lock-register} to register a Font
Lock fontification function, which will be called whenever parts of a
buffer are (re)fontified because a window was scrolled or its size
changed.  @xref{Other Font Lock Variables}.

@ignore
   arch-tag: 3f6c36e8-df49-4986-b757-417feed88be3
@end ignore
