@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2011
@c   Free Software Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@setfilename ../../info/windows
@node Windows, Positions, Frames, Top
@chapter Windows

  This chapter describes the functions and variables related to Emacs
windows.  @xref{Display}, for information on how text is displayed in
windows.

@menu
* Basic Windows::           Basic information on using windows.
* Windows and Frames::      Relating windows to the frame they appear on.
* Window Sizes::            Accessing a window's size.
* Resizing Windows::        Changing the sizes of windows.
* Splitting Windows::       Splitting one window into two windows.
* Deleting Windows::        Deleting a window gives its space to other windows.
* Selecting Windows::       The selected window is the one that you edit in.
* Cyclic Window Ordering::  Moving around the existing windows.
* Buffers and Windows::     Each live window displays the contents of a buffer.
* Displaying Buffers::      How to choose a window for displaying a buffer.
* Switching Buffers::       Higher-level functions for switching to a buffer
                              in some window.
* Dedicated Windows::       How to avoid displaying another buffer in
                              a specific window.
* Window Point::            Each window has its own location of point.
* Window Start and End::    Buffer positions indicating which text is
                              on-screen in a window.
* Textual Scrolling::       Moving text up and down through the window.
* Vertical Scrolling::      Moving the contents up and down on the window.
* Horizontal Scrolling::    Moving the contents sideways on the window.
* Coordinates and Windows:: Determining a window's edges and
                              converting coordinates to windows.
* Window Configurations::   Saving and restoring the state of the screen.
* Window Parameters::       Associating additional information with windows.
* Atomic Windows::          Gluing windows together.
* Side Windows::            Grouping side windows around a main window.
* Window Hooks::            Hooks for scrolling, window size changes,
                              redisplay going past a certain point,
                              or window configuration changes.
@end menu


@node Basic Windows
@section Basic Concepts of Emacs Windows
@cindex window

A @dfn{window} in Emacs is the physical area of the screen in which a
buffer is displayed.  The term is also used to refer to a Lisp object
that represents that screen area in Emacs Lisp.  It should be clear from
the context which is meant.

@cindex multiple windows
  Emacs groups windows into frames; see @ref{Frames}.  Each frame always
contains at least one window, but you can subdivide it into multiple,
non-overlapping Emacs windows.  Users create multiple windows so they
can look at several buffers at once.  Lisp libraries use multiple
windows for a variety of reasons, but most often to display related
information.  In Rmail, for example, you can move through a summary
buffer in one window while the other window shows messages one at a time
as they are reached.

@cindex terminal screen
@cindex screen of terminal
  The meaning of ``window'' in Emacs is similar to what it means in the
context of general-purpose window systems such as X, but not identical.
The X Window System places X windows on the screen; Emacs uses one or
more X windows as frames, and subdivides them into Emacs windows.  When
you use Emacs on a character-only terminal, Emacs treats the whole
terminal screen as one frame.

@cindex tiled windows
  Most window systems support arbitrarily located overlapping windows.
In contrast, Emacs windows are @dfn{tiled}; they never overlap, and
together they fill the whole screen or frame.  Because of the way in
which Emacs creates new windows (@pxref{Splitting Windows}) and resizes
them (@pxref{Resizing Windows}), not all conceivable tilings of windows
on an Emacs frame are actually possible.

  For practical purposes, a window exists only while it is displayed in
a frame.  Once removed from the frame, the window is effectively deleted
and should not be used, @emph{even though there may still be references
to it} from other Lisp objects; see @ref{Deleting Windows}.  Restoring a
saved window configuration is the only way for a window no longer on the
screen to come back to life; see @ref{Window Configurations}.

@defun windowp object
This function returns @code{t} if @var{object} is a window and
@code{nil} otherwise.
@end defun

@cindex live windows
@cindex internal windows
   For historical reasons a window is considered @dfn{live} if and only
if it currently displays a buffer; see @ref{Buffers and Windows}.  In
order to show multiple windows within one and the same frame, Emacs
organizes them in form of a tree called window tree; see @ref{Windows
and Frames}.  The internal nodes of a window tree are called internal
windows and are not considered live.  The leaf nodes of a window tree
constitute the windows displaying buffers and only they will be called
live here.  The selected window (@pxref{Selecting Windows}) is always a
live window.

@defun window-live-p object
This function returns @code{t} if @var{object} is a live window and
@code{nil} otherwise.  A live window is a window that displays a buffer.
@end defun

@defun window-internal-p object
This function returns @code{t} if @var{object} denotes an internal
window and @code{nil} otherwise.  An internal window is a window that
has at least two child windows, see @ref{Windows and Frames}.
@end defun

@defun window-any-p object
This function returns @code{t} if @var{object} denotes a live or an
internal window and @code{nil} otherwise.  In particular, this function
returns @code{nil} if @var{object} is a window that has been
deleted.
@end defun

   The window handling functions can be roughly grouped into functions
operating on live windows only and functions that accept any window as
argument.  Many of these functions accept the value @code{nil} to
specify the selected window.  The two functions below can be used to
``normalize'' arguments specifying windows in a uniform manner.

@defun normalize-any-window window
This function returns the normalized value for @var{window} which can be
any window that has not been deleted.  More precisely, if @var{window}
is @code{nil} it returns the selected window.  If @var{window} is
non-@code{nil} and denotes a live or an internal window, this function
returns @var{window}.  In any other case this function signals an error.
@end defun

@defun normalize-live-window window
This functions returns the normalized value for a live window
@var{window}.  More precisely, if @var{window} is @code{nil} it returns
the selected window.  Otherwise, if @var{window} is a live window this
function returns @var{window}.  If @var{window} is neither @code{nil}
nor a live window this function signals an error.
@end defun


@node Windows and Frames
@section Windows and Frames

Each window is part of one and only one frame (@pxref{Frames}); you can
get that frame with the function described next.

@defun window-frame window
This function returns the frame that @var{window} is on.  The argument
@var{window} can be any window and defaults to the selected one.
@end defun

The following function returns a list of all live windows on a specific
frame.

@defun window-list &optional frame minibuf window
This function returns a list of @var{frame}'s live windows, starting
with @var{window}.  The argument @var{frame} has to denote a live frame
and defaults to the selected frame.  The argument @var{window} has to
denote a live window on the frame specified by @var{frame} and defaults
to the selected one.

The argument @var{minibuf} specifies if the minibuffer window shall be
included in the return value.  If @var{minibuf} is @code{t}, the result
always includes the minibuffer window.  If @var{minibuf} is @code{nil}
or omitted, that includes the minibuffer window only if it is active.
If @var{minibuf} is neither @code{nil} nor @code{t}, the result never
includes the minibuffer window.
@end defun

@cindex window tree
Windows within one and the same frame are organized in form of a tree
called @dfn{window tree}.  The leaf nodes of a window tree constitute
the windows visible to the user.  These are the windows associated with
buffers and are usually called live or leaf windows.  The internal nodes
of a window tree are needed for finding, traversing and displaying the
leaf windows.

   A minibuffer window (@pxref{Minibuffer Windows}) is not considered
part of its frame's window tree unless the frame is a minibuffer-only
frame.  Most functions covered in this section accept, however, the
minibuffer window as argument.  Also, the minibuffer window is listed by
the function @code{window-tree} described at the end of this section.

   A window tree is rooted at the root window of its frame.

@defun frame-root-window &optional frame-or-window
This function returns the root window of @var{frame-or-window}.  The
argument @var{frame-or-window} has to denote either a window or a frame
and defaults to the selected frame.  If @var{frame-or-window} denotes a
window, the return value is the root window of that window's frame.
This function always returns a window; a live window if the frame
specified by @var{frame-or-window} contains no other live windows and an
internal window otherwise.
@end defun

@cindex subwindow
All other windows of a frame with the exception of the minibuffer window
are subwindows of the frame's root window.  A window is considered a
@dfn{subwindow} of another window if it occupies a part of that other
window's screen area.

The functions described next allow to access the members of a window
tree and take an arbitrary window as argument.

@cindex parent window
@defun window-parent &optional window
Return @var{window}'s parent in the window tree.  The optional argument
@var{window} can denote an arbitrary window and defaults to the selected
one.  The return value is @code{nil} if @var{window} is a minibuffer
window or the root window of its frame and an internal window otherwise.
@end defun

@cindex child window
   Parent windows do not appear on the screen.  The screen area of a
parent window is the rectangular part of the window's frame occupied by
the window's @dfn{child windows}, that is, the set of windows having
that window as their parent.  Each parent window has at least two child
windows, so there are no ``Matryoshka'' windows.  Minibuffer windows do
not have child windows.

@cindex window combination
@cindex vertical combination
@cindex horizontal combination
The children of any parent window form either a vertical or a horizontal
combination of windows.  A @dfn{vertical combination} is a set of
windows arranged one above each other.  A @dfn{horizontal combination}
is a set of windows arranged side by side.  Consider the frame shown
below (for simplicity we assume that the frame does not contain a
minibuffer):

@smallexample
@group
     ______________________________________
    | ______  ____________________________ |
    ||      || __________________________ ||
    ||      ||| ___________  ___________ |||
    ||      ||||           ||           ||||
    ||      ||||           ||           ||||
    ||      ||||_____W6____||_____W7____||||
    ||      |||____________W4____________|||
    ||      || __________________________ ||
    ||      |||                          |||
    ||      |||____________W5____________|||
    ||__W2__||_____________W3_____________ |
    |__________________W1__________________|

@end group
@end smallexample

The root window of the frame is @code{W1}---a horizontal combination of
the leaf window @code{W2} and @code{W3}.  Hence @code{(window-parent
W1)} is @code{nil} while @code{(window-parent W2)} and
@code{(window-parent W3)} both evaluate to (the window object
representing) @code{W1}.

   The internal window @code{W3} is a vertical combination of @code{W4}
and the leaf window @code{W5}.  The internal window @code{W4} is a
horizontal combination of the leaf windows @code{W6} and @code{W7}.  The
windows you actually see on your screen are @code{W2}, @code{W5},
@code{W6} and @code{W7}.

   For any parent window, the first child window can be retrieved by the
functions given next.

@defun window-vchild &optional window
This function returns @var{window}'s first vertical child window.  The
optional argument @var{window} can be an arbitrary window and defaults
to the selected one.  The return value is @code{nil} if @var{window} is
a leaf window or its children form a horizontal combination.  In the
example above @code{(window-vchild W3)} is @code{W4} while
@code{(window-vchild W4)} is @code{nil}.
@end defun

@defun window-hchild &optional window
This function returns @var{window}'s first horizontal child window.  The
optional argument @var{window} can be an arbitrary window and defaults
to the selected one.  The return value is @code{nil} if @var{window} is
a leaf window or its children form a vertical combination.  In the
example above @code{(window-hchild W4)} is @code{W6} while
@code{(window-vchild W3)} is @code{nil}.
@end defun

@defun window-child window
This function return @var{window}'s first child window.  The return
value is @code{nil} if @var{window} is a leaf window.  In the example
above @code{(window-child W3)} is @code{W4} while @code{(window-vchild
W4)} is @code{W6}.
@end defun

The following function is useful to determine whether a window is part
of a vertical or horizontal combination.

@defun window-iso-combined-p &optional window horizontal
This function returns non-@code{nil} if and only if @var{window} is
vertically combined.  The argument @var{window} can specify any window
and defaults to the selected one.  The actual return value is the first
vertical child of window.

If the optional argument @var{horizontal} is non-@code{nil}, this means
to return non-@code{nil} if and only if @var{window} is horizontally
combined.  The actual return value is the first horizontal child of
window.

In our canonical example @code{(window-iso-combined-p W5)} and
@code{(window-iso-combined-p W6 t)} both evaluate to @code{t} while
@code{(window-iso-combined-p W6)} is @code{nil}.
@end defun

@cindex sibling window
For any window that is part of a combination, the other windows in that
combination are called the window's @dfn{siblings}.  The only windows
that do not have siblings are root windows of frames and minibuffer
windows.  A window's siblings can be retrieved with the following two
functions.

@defun window-next &optional window
This function returns @var{window}'s right sibling.  The optional
argument @var{window} can be an arbitrary window and defaults to the
selected window.  It returns @code{nil} if @var{window} has no right
sibling.  Applying this function recursively will eventually get you to
the last child of @var{window}'s parent.  In our example
@code{(window-next W2)} is @code{W3} while @code{(window-next W3)} is
@code{nil}.
@end defun

@defun window-prev &optional window
This function returns @var{window}'s left sibling.  The optional
argument @var{window} can be an arbitrary window and defaults to the
selected window.  It returns @code{nil} if @var{window} has no left
sibling.  Applying this function recursively will eventually get you to
the first child of @var{window}'s parent.  In our example
@code{(window-prev W3)} is @code{W2} and @code{(window-prev W2)} is
@code{nil}.
@end defun

The functions @code{window-next} and @code{window-prev} should not be
confused with the functions @code{next-window} and
@code{previous-window} which respectively return the next and previous
window in the cyclic ordering of windows, see @ref{Cyclic Window
Ordering}.

   In order to find the first live window on a frame, the following
function can be used.

@defun frame-first-window &optional frame-or-window
This function returns the live window at the upper left corner of the
frame specified by @var{frame-or-window}.  The argument
@var{frame-or-window} must denote a window or a live frame and defaults
to the selected frame.  If @var{frame-or-window} specifies a window,
this function returns the first window on that window's frame.  Under
the assumption that the frame from our canonical example is selected
@code{(frame-first-window)} returns @code{W2}.
@end defun

You can get the window tree of a frame with the following function.

@cindex window tree
@defun window-tree &optional frame
This function returns the window tree for frame @var{frame}.  The
optional argument @var{frame} must be a live frame and defaults to the
selected one.

The return value is a list of the form @code{(@var{root} @var{mini})},
where @var{root} represents the window tree of the frame's
root window, and @var{mini} is the frame's minibuffer window.

If the root window is live, @var{root} specifies the root window and
nothing else.  Otherwise, @var{root} is a list @code{(@var{dir}
@var{edges} @var{w1} @var{w2} ...)} where @var{dir} is @code{nil} for a
horizontal combination, and @code{t} for a vertical combination,
@var{edges} gives the size and position of the combination, and the
remaining elements are the child windows.  Each child window may again
be a live window or a list representing a window combination, and so on.
The @var{edges} element is a list @code{(@var{left}@var{ top}@var{
right}@var{ bottom})} similar to the value returned by
@code{window-edges}, see @ref{Coordinates and Windows}.
@end defun


@node Window Sizes
@section Window Sizes
@cindex window size
@cindex size of window

Emacs windows are rectangular.  The structure of a live window can be
roughly sketched as follows:

@smallexample
@group
         _________________________________________ 
      ^ |______________ Header Line_______________| 
      | |LS|LF|LM|                       |RM|RF|RS| ^
      | |  |  |  |                       |  |  |  | |
 Window |  |  |  |       Text Area       |  |  |  | Window
 Total  |  |  |  |     (Window Body)     |  |  |  | Body
 Height |  |  |  |                       |  |  |  | Height
      | |  |  |  |<- Window Body Width ->|  |  |  | |
      | |__|__|__|_______________________|__|__|__| v
      v |_______________ Mode Line _______________|

         <----------- Window Total Width -------->

@end group
@end smallexample

@cindex window body
@cindex body of a window
The text area constitutes the body of the window.  In its most simple
form, a window consists of its body alone.  LS and RS stand for the left
and right scroll bar (@pxref{Scroll Bars}) respectively.  Only one of
them can be present at any time.  LF and RF denote the left and right
fringe, see @ref{Fringes}.  LM and RM, finally, stand for the left and
right display margin, see @ref{Display Margins}.  The header line, if
present, is located above theses areas, the mode line below, see
@ref{Mode Line Format}.

@cindex window height
@cindex total window height
@cindex height of a window
@cindex total height of a window
The @dfn{total height of a window} is specified as the total number of
lines occupied by the window.  Any mode or header line is included in a
window's total height.  For an internal window, the total height is
calculated recursively from the total heights of its child windows.

@cindex window width
@cindex total window width
@cindex width of a window
@cindex total width of a window
The @dfn{total width of a window} denotes the total number of columns of
the window.  Any scroll bar and the column of @samp{|} characters that
separate the window from its right sibling are included in a window's
total width.  On a window-system, fringes and display margins are
included in a window's total width too.  For an internal window, the
total width is calculated recursively from the total widths of its child
windows.

@cindex total size of a window
@cindex total window size
The following function is the standard interface for getting the total
size of any window:

@defun window-total-size &optional window &optional horizontal
This function returns the total number of lines of @var{window}.  The
argument @var{window} can denote any window and defaults to the selected
one.  If @var{window} is live, the return value includes any header or
mode lines of @var{window}.  If @var{window} is internal, the return
value is the sum of the total heights of @var{window}'s child windows
provided these are vertically combined and the height of @var{window}'s
first child if they are horizontally combined.

   If the optional argument @var{horizontal} is non-@code{nil}, this
function returns the total number of columns of @var{window}.  If
@var{window} is live, the return value includes any vertical divider
column or scroll bars of @var{window}.  On a window-system, the return
value includes the space occupied by any margins and fringes of
@var{window} too.  If @var{window} is internal, the return value is the
sum of the total widths of @var{window}'s child windows provided these
are horizontally combined and the width of @var{window}'s first child
otherwise.
@end defun

Alternatively, the following two functions can be used to retrieve
either the total height of the total width of a window:

@defun window-total-height &optional window
This function returns the total number of lines of @var{window}.
@var{window} can be any window and defaults to the selected one.  The
return value includes @var{window}'s mode line and header line, if any.
If @var{window} is internal the return value is the sum of heights of
@var{window}'s child windows for a vertical combination and the height
of @var{window}'s first child otherwise.
@end defun

@defun window-total-width &optional window
This function returns the total number of columns of @var{window}.
@var{window} can be any window and defaults to the selected one.  The
return value includes any vertical dividers or scrollbars of
@var{window}.  On a window-system the return value also includes the
space occupied by any margins and fringes of @var{window}.  If
@var{window} is internal, the return value is the sum of the widths of
@var{window}'s child windows for a horizontal combination and the width
of @var{window}'s first child otherwise.
@end defun

The total height of any window is usually less than the height of the
window's frame, because the latter may also include the minibuffer
window.  Depending on the toolkit in use, the frame height can also
include the menu bar and the tool bar (@pxref{Size and Position}).
Therefore, in general it is not straightforward to compare window and
frame heights.  The following function is useful to determine whether
there are no other windows above or below a specified window.

@cindex full-height window
@defun window-full-height-p &optional window
This function returns non-@code{nil} if there is no other window above
or below @var{window} on the containing frame.  More precisely, this
function returns @code{t} if and only if the total height of
@var{window} equals the total height of the root window (@pxref{Windows
and Frames}) of @var{window}'s frame.  The @var{window} argument may
denote any window and defaults to the selected one.
@end defun

@cindex full-width window
The following function can be used to determine whether there are no
other windows on the left or right of a specified window.

@defun window-full-width-p &optional window
This function returns non-@code{nil} if there are no other windows on
the left or right of @var{window}; @code{nil} otherwise.  More
precisely, this function returns @code{t} if and only if the total width
of @var{window} equals the total width of the root window
(@pxref{Windows and Frames}) of @var{window}'s frame.  The @var{window}
argument may denote any window and defaults to the selected one.
@end defun

@cindex top line of window
@cindex left column of window
  The windows of a frame are unambiguously characterized by the
combination of their top line and left column within that frame.

@defun window-top-line &optional window
This function returns the top line of @var{window}.  The argument
@var{window} can denote any window and defaults to the selected one.
@end defun

@defun window-left-column &optional window
This function returns the left column of @var{window}.  The argument
@var{window} can denote any window and defaults to the selected one.
@end defun

For a frame displaying one window only, that window's top line and left
column are both zero.  When a frame displays a window @var{WB} below a
window @var{WA}, the top line of @var{WB} can be calculated by adding
the total height of @var{WA} to the top line of @var{WA}.  When a frame
displays a window @var{WR} on the right of a window @var{WL}, the left
column of @var{WR} can be calculated by adding the total width of
@var{WL} to the left column of @var{WL}.

@cindex window body height
@cindex body height of a window
The @dfn{body height of a window} is specified as the total number of
lines occupied by the window's text area.  Mode or header lines are not
included in a window's body height.

@cindex window body width
@cindex body width of a window
The @dfn{body width of a window} denotes the total number of columns
occupied by the window's text area.  Scroll bars or columns of @samp{|}
characters that separates side-by-side windows are not included in a
window's body width.

@cindex body size of a window
@cindex window body size
The following functions retrieve height and width of the body of a live
window:

@defun window-body-size &optional window horizontal
This function returns the number of lines of @var{window}'s text area.
@var{window} must be a live window and defaults to the selected one.
The return value does not count any mode or header line of @var{window}.

Optional argument @var{horizontal} non-@code{nil} means to return the
number of columns of @var{window}'s text area.  In this case the return
value does not include any vertical divider or scroll bar owned by
@var{window}.  On a window-system the return value does not include the
number of columns used for @var{window}'s fringes or display margins
either.
@end defun

@defun window-body-height &optional window
This function returns the number of lines of @var{window}'s body.
@var{window} must be a live window and defaults to the selected one.

The return value does not include @var{window}'s mode line and header
line, if any.  If a line at the bottom of the window is only partially
visible, that line is included in the return value.  If you do not
want to include a partially visible bottom line in the return value,
use @code{window-text-height} instead.
@end defun

@defun window-body-width &optional window
This function returns the number of columns of @var{window}'s body.
@var{window} must be a live window and defaults to the selected one.

The return value does not include any vertical dividers or scroll bars
owned by @var{window}.  On a window-system the return value does not
include the number of columns used for @var{window}'s fringes or
display margins either.
@end defun

The following functions have been used in earlier versions of Emacs.
They are still supported but due to the confusing nomenclature they
should not be used any more in future code.

@defun window-height &optional window
This function is an alias for `window-total-height', see above.
@end defun

@defun window-width &optional window
This function is an alias for `window-body-width', see above.
@end defun

@cindex minimum window size
  The following two options constrain the sizes of windows to a minimum
height and width.  Their values are honored when windows are split
(@pxref{Splitting Windows}) or resized (@pxref{Resizing Windows}).  Any
request to make a window smaller than specified here will usually result
in an error.

@defopt window-min-height
The value of this variable specifies how short a window may be.  The
value is measured in line units and has to account for any header or
mode line.  The default value for this option is @code{4}.  Values less
than @code{1} are ignored.
@end defopt

@defopt window-min-width
The value of this variable specifies how narrow a window may be.  The
value is measured in characters and includes any margins, fringes,
scroll bar and vertical divider column.  The default value for this
option is @code{10}.  A value less than @code{2} is ignored.
@end defopt

Applications should not rebind these variables.  To shrink a specific
window to a height or width less than the one specified here, they
should rather invoke @code{resize-window} (@pxref{Resizing Windows})
with a non-@code{nil} @var{ignore} argument.  The function
@code{split-window} (@pxref{Splitting Windows}) can make a window
smaller than specified here by calling it with a non-@code{nil}
@var{size} argument.  Interactively, the values specified here cannot be
overridden.

   Earlier versions of Emacs could delete a window when its size dropped
below @code{window-min-height} or @code{window-min-width}.  As a rule,
the current version of Emacs does no more delete windows by side-effect.
The only exception to this rule are requests to resize a frame which may
implicitly delete windows when they do not fit on the frame any more,
see @ref{Size and Position}.

   The size of a window can be fixed which means that it cannot be split
(@pxref{Splitting Windows}) or resized (@pxref{Resizing Windows}).

@cindex fixed-size window
@defvar window-size-fixed
If this variable is non-@code{nil}, in a given buffer, then the size of
any window displaying that buffer remains fixed unless you either
explicitly change it or Emacs has no other choice.

If the value is @code{height}, then only the window's height is fixed;
if the value is @code{width}, then only the window's width is fixed.
Any other non-@code{nil} value fixes both the width and the height.

This variable automatically becomes buffer-local when set.
@end defvar

Commands supposed to explicitly change the size of windows such as
@code{enlarge-window} (@pxref{Resizing Windows}) get an error if they
had to change a window size which is fixed.  Other functions like
@code{resize-window} (@pxref{Resizing Windows}) have an optional
@var{ignore} argument which allows to change the size of fixed-size
windows.

   Deleting a window or changing a frame's size may change the size of a
fixed-size window, if there is no other alternative.

   A vertical combination of windows cannot be resized when the height
of all windows in that combination is fixed.  A horizontal combination
cannot be resized when the width of all windows in it is fixed.  The
next function allows to check whether the size of an arbitrary window is
fixed.

@defun window-size-fixed-p &optional window horizontal
This function returns non-@code{nil} if @var{window}'s height is fixed.
The argument @var{window} can be an arbitrary window and defaults to the
selected one.  Optional argument @var{horizontal} non-@code{nil} means
return non-@code{nil} if @var{window}'s width is fixed.

If this function returns @code{nil}, this does not necessarily mean that
@var{window} can be resized in the desired direction.  The function
@code{window-resizable} (@pxref{Resizing Windows}) can tell that.
@end defun


@node Resizing Windows
@section Resizing Windows
@cindex window resizing
@cindex resize window
@cindex changing window size
@cindex window size, changing

Emacs does not permit overlapping windows or gaps between windows, so
changing the size of a window always affects at least one other window.
When a frame contains just one window, that window can be resized only
by resizing the window's frame.  The functions described below are
therefore meaningful only in the context of a frame containing at least
two windows.  The size of the corresponding frame never changes when
invoking a function described in this section.

   The routines changing window sizes always operate in one dimension at
a time.  This means that windows can be resized only either vertically
or horizontally.  If a window shall be resized in both dimensions, it
must be resized in one dimension first and in the other dimension
afterwards.  If the second resize operation fails, the frame might end
up in an unsatisfactory state.  To avoid such states, it might be useful
to save the current window configuration (@pxref{Window Configurations})
before attempting the first resize operation and restore the saved
configuration in case the second resize operation fails.

   Functions that resize windows are supposed to obey restrictions
imposed by window minimum sizes and fixed-size windows, see @ref{Window
Sizes}.  In order to determine whether resizing a specific window is
possible in the first place, the following function can be used:

@defun window-resizable window delta &optional horizontal ignore side noup nodown
This function returns @var{delta} if the size of @var{window} can be
changed vertically by @var{delta} lines.  Optional argument
@var{horizontal} non-@code{nil} means to return @var{delta} if
@var{window} can be resized horizontally by @var{delta} columns.  A
return value of zero means that @var{window} is not resizable.

If @var{delta} is a positive number, this means that @var{window} shall
be enlarged by @var{delta} lines or columns.  If @var{window} cannot be
enlarged by @var{delta} lines or columns this function returns the
maximum value in the range from 0 to @var{delta} by which @var{window}
can be enlarged.

If @var{delta} is a negative number, this means that @var{window} shall
be shrunk by -@var{delta} lines or columns.  If @var{window} cannot be
shrunk by -@var{delta} lines or columns, this function returns the
minimum value in the range from @var{delta} to 0 that can be used for
shrinking @var{window}.

Optional argument @var{ignore} non-@code{nil} means ignore any
restrictions imposed by the variables @code{window-min-height} or
@code{window-min-width} and @code{window-size-fixed}.  In this case the
minimum height of a window is specified as the minimum number of lines
that allow viewing any header or mode line and at least one line of the
text area of window.  The minimum width of a window includes any
fringes, margins and the scroll bar as well as two text columns.

If @var{ignore} denotes a window, this means to ignore restrictions for
that window only.  If @var{ignore} equals the constant @code{safe}, this
means a live window may get as small as one line or two columns.

Optional argument @var{noup} non-@code{nil} means don't go up in the
window tree but try to steal or distribute the space needed for the
resize operation among the other windows within @var{window}'s
combination.  Optional argument @var{nodown} non-@code{nil} means don't
check whether @var{window} and its subwindows can be resized.
@end defun

The function @code{window-resizable} does not change any window sizes.
The following function does:

@defun resize-window window delta &optional horizontal ignore
This function resizes @var{window} vertically by @var{delta} lines.  The
argument @var{window} can denote an arbitrary window and defaults to the
selected one.  An attempt to resize the root window of a frame will
raise an error.

Second argument @var{delta} a positive number means @var{window} shall
be enlarged by @var{delta} lines.  If @var{delta} is negative, that
means @var{window} shall be shrunk by -@var{delta} lines.

Optional argument @var{horizontal} non-@code{nil} means to resize
@var{window} horizontally by @var{delta} columns.  In this case a
positive @var{delta} means enlarge @var{window} by @var{delta} columns.
A negative @var{delta} means @var{window} shall be shrunk by
-@var{delta} columns.

Optional argument @var{ignore} has the same meaning as for the function
@code{window-resizable} above.

This function resizes other windows proportionally and never deletes any
windows.  If only the low (right) edge of @var{window} shall be moved,
the function @code{adjust-window-trailing-edge} described below should
be used.
@end defun

The next four commands are simple interfaces to @code{resize-window}.
They always operate on the selected window, never delete any window, and
always raise an error when resizing would violate a restriction imposed
by @code{window-min-height}, @code{window-min-width}, or
@code{window-size-fixed}.

@deffn Command enlarge-window delta &optional horizontal
This function makes the selected window @var{delta} lines taller.
Interactively, if no argument is given, it makes the selected window one
line taller.  If optional argument @var{horizontal} is non-@code{nil},
it makes the selected window wider by @var{delta} columns.  If
@var{delta} is negative, it shrinks the selected window by -@var{delta}
lines or columns.  The return value is @code{nil}.
@end deffn

@deffn Command enlarge-window-horizontally delta
This function makes the selected window @var{delta} columns wider.
Interactively, if no argument is given, it makes the selected window one
column wider.
@end deffn

@deffn Command shrink-window delta &optional horizontal
This function makes the selected window @var{delta} lines smaller.
Interactively, if no argument is given, it makes the selected window one
line smaller.  If optional argument @var{horizontal} is non-@code{nil},
it makes the selected window narrower by @var{delta} columns.  If
@var{delta} is negative, it enlarges the selected window by -@var{delta}
lines or columns.  The return value is @code{nil}.
@end deffn

@deffn Command shrink-window-horizontally delta
This function makes the selected window @var{delta} columns narrower.
Interactively, if no argument is given, it makes the selected window one
column narrower.
@end deffn

@defun adjust-window-trailing-edge window delta &optional horizontal
This function moves @var{window}'s bottom edge by @var{delta} lines.
Optional argument @var{horizontal} non-@code{nil} means to move
@var{window}'s right edge by @var{delta} columns.  The argument
@var{window} defaults to the selected window.

If the edge can't be moved by @var{delta} lines, move it as far as
possible in the desired direction.
@end defun

@deffn Command fit-window-to-buffer &optional window max-height min-height override
This command makes @var{window} the right height to display its
contents exactly.  The default for @var{window} is the selected window.

The optional argument @var{max-height} specifies the maximum height the
window is allowed to be; @code{nil} means use the maximum permissible
height of a window on @var{window}'s frame.  The optional argument
@var{min-height} specifies the minimum height for the window; @code{nil}
means use @code{window-min-height}.  All these height values include the
mode line and/or header line.

If the optional argument @var{override} is non-@code{nil}, this means to
ignore any restrictions imposed by @code{window-min-height} and
@code{window-min-width} on the size of @var{window}.

This function returns non-@code{nil} if it orderly resized @var{window},
and @code{nil} otherwise.
@end deffn

@deffn Command shrink-window-if-larger-than-buffer &optional window
This command shrinks @var{window} vertically to be as small as possible
while still showing the full contents of its buffer---but not less than
@code{window-min-height} lines.  The argument @var{window} must denote
a live window and defaults to the selected one.

However, this command does nothing if the window is already too small to
display the whole text of the buffer, or if part of the contents are
currently scrolled off screen, or if the window is not the full width of
its frame, or if the window is the only window in its frame.

This command returns non-@code{nil} if it actually shrank the window
and @code{nil} otherwise.
@end deffn

@cindex balancing window sizes
Emacs provides two functions to balance windows, that is, to even out
the sizes of windows on the same frame.  The minibuffer window and
fixed-size windows are not resized by these functions.

@deffn Command balance-windows &optional window-or-frame
This function balances windows in a way that gives more space to
full-width and/or full-height windows.  If @var{window-or-frame}
specifies a frame, it balances all windows on that frame.  If
@var{window-or-frame} specifies a window, it balances that window and
its siblings (@pxref{Windows and Frames}) only.
@end deffn

@deffn Command balance-windows-area
This function attempts to give all windows on the selected frame
approximately the same share of the screen area.  This means that
full-width or full-height windows are not given more space than other
windows.
@end deffn

@cindex maximizing windows
The following function can be used to give a window the maximum possible
size without deleting other ones.

@deffn Command maximize-window &optional window
This function maximizes @var{window}.  More precisely, this makes
@var{window} as large as possible without resizing its frame or deleting
other windows.  @var{window} can be any window and defaults to the
selected one.
@end deffn

@cindex minimizing windows
To make a window as small as possible without deleting it the
following function can be used.

@deffn Command minimize-window &optional window
This function minimizes @var{window}.  More precisely, this makes
@var{window} as small as possible without deleting it or resizing its
frame.  @var{window} can be any window and defaults to the selected one.
@end deffn


@node Splitting Windows
@section Splitting Windows
@cindex splitting windows
@cindex window splitting

The functions described below are the primitives needed for creating a
new window.  They do not accept a buffer as an argument.  Rather, they
``split'' an existing window into two halves, both displaying the buffer
previously visible in the window that was split.

@deffn Command split-window &optional window size horizontal
This function creates a new window adjacent to @var{window}.  It returns
the new window which is always a live window.  The argument @var{window}
can denote any window and defaults to the selected one.  This function
does not change the selected window.

Optional second argument @var{size} a positive number means make
@var{window} @var{size} lines (or columns) tall.  If @var{size} is
negative, make the new window @minus{}@var{size} lines (or columns)
tall.  If @var{size} is omitted or @code{nil}, then @var{window} is
divided evenly into two parts.  (If there is an odd line, it is
allocated to the new window.)

If splitting would result in making a window smaller than
@code{window-min-height} or @code{window-min-width} (@pxref{Window
Sizes}), this function usually signals an error.  However, if @var{size}
is non-@code{nil} and valid, a new window of the requested size is
created.  (A size value would be invalid if it assigned less than one
line or less than two columns to the new window.)

Optional third argument @var{horizontal} @code{nil} (or @code{below})
specifies that the new window shall be located below @var{window}.  The
value @code{above} means the new window will be located above
@var{window}.  In both cases @var{size} specifies the new number of
lines for @var{window} (or the new window if @var{size} is negative)
including space reserved for the mode and/or header line.

If @var{horizontal} is @code{t} or @code{right} the new window will be
positioned on the right side of @var{window}.  The value @code{left}
means the new window will be located on the left side of @var{window}.
In both cases @var{size} specifies the new number of columns for
@var{window} (or the new window provided @var{size} is negative)
including space reserved for margins, fringes and the scroll bar or a
divider column.

Any other non-@code{nil} value for @var{horizontal} is currently handled
like @code{t} (or @code{right}).  Since this might change in the future,
application programs should refrain from using other values.

If @var{window} is live, properties of the new window like margins and
scroll bars are inherited from @var{window}.  If @var{window} is an
internal window, these properties, as well as the buffer shown in the
new window, are inherited from the window selected on @var{window}'s
frame.

If @code{ignore-window-parameters} is non-@code{nil}, this function
ignores window parameters (@pxref{Window Parameters}).  Otherwise, if
the @code{split-window-function} parameter of @var{window} is @code{t},
it splits the window disregarding any other window parameters.  If the
@code{split-window-function} parameter specifies a function, that
function is called with the arguments @var{window}, @var{size}, and
@var{horizontal} to split @var{window}.  If that function is
@code{ignore}, nothing is done.

Otherwise, if @var{window} is a subwindow of an atomic window
(@pxref{Atomic Windows}) this function splits the root of the atomic
window instead.  The new window does not become a subwindow of the
atomic window.  If @var{window} is a non-side window (@pxref{Side
Windows}), the new window becomes a non-side window too.  If
@var{window} is a side window, the new window becomes a side window too.
@end deffn

The following example starts with one window on a screen that is 50
lines high by 80 columns wide; then it splits the window.

@smallexample
@group
(setq W1 (selected-window))
     @result{} #<window 8 on windows.texi>
(setq W2 (split-window W1 15))
     @result{} #<window 28 on windows.texi>
@end group
@group
(window-top-line W1)
     @result{} 0
(window-total-size W1)
     @result{} 15
(window-top-line W2)
     @result{} 15
@end group
@end smallexample

The screen looks like this:

@smallexample
@group
         __________
        |          |  line 0
        |    W1    |
        |__________|
        |          |  line 15
        |    W2    |
        |__________|
                      line 50
 column 0   column 80
@end group
@end smallexample

Next, split the top window horizontally:

@smallexample
@group
(setq W3 (split-window W1 35 t))
     @result{} #<window 32 on windows.texi>
@end group
@group
(window-left-column W1)
     @result{} 0
(window-total-size W1 t)
     @result{} 35
(window-left-column W3)
     @result{} 35
@end group
@end smallexample

@need 3000
Now the screen looks like this:

@smallexample
@group
     column 35
         __________
        |    |     |  line 0
        | W1 |  W3 |
        |____|_____|
        |          |  line 15
        |    W2    |
        |__________|
                      line 50
 column 0   column 80
@end group
@end smallexample

Normally, Emacs indicates the border between two side-by-side windows
with a scroll bar (@pxref{Scroll Bars}), or with @samp{|} characters.  The
display table can specify alternative border characters; see @ref{Display
Tables}.

Below we describe how @code{split-window} can be used to create the
window configuration from our earlier example (@pxref{Windows and
Frames}) and how internal windows are created for this purpose.  We
start with a frame containing one leaf window @code{W2} (in the
following scenarios window names are assigned in an arbitrary manner in
order to match the names of the example).
@smallexample
@group
     ______________________________________
    |                                      |
    |                                      |
    |                                      |
    |                                      |
    |                                      |
    |                                      |
    |                                      |
    |                                      |
    |                                      |
    |                                      |
    |                                      |
    |                                      |
    |__________________W2__________________|

@end group
@end smallexample

Evaluating the form @code{(split-window W2 8 t)} creates a new internal
window @code{W1} with two children---@code{W2} (the window we've split)
and a new leaf window @code{W6}:
@smallexample
@group
     ______________________________________
    | ______  ____________________________ |
    ||      ||                            ||
    ||      ||                            ||
    ||      ||                            ||
    ||      ||                            ||
    ||      ||                            ||
    ||      ||                            ||
    ||      ||                            ||
    ||      ||                            ||
    ||      ||                            ||
    ||      ||                            ||
    ||__W2__||_____________W6_____________ |
    |__________________W1__________________|

@end group
@end smallexample

Evaluating now @code{(split-window W6 -3)} creates another internal
window @code{W3} with two children---@code{W6} and a new leaf window
@code{W5}.  This leaves us with a vertically combined window @code{W3}
embedded in the horizontally combined window @code{W1}:
@smallexample
@group
     ______________________________________
    | ______  ____________________________ |
    ||      || __________________________ ||
    ||      |||                          |||
    ||      |||                          |||
    ||      |||                          |||
    ||      |||                          |||
    ||      |||                          |||
    ||      |||____________W6____________|||
    ||      || __________________________ ||
    ||      |||                          |||
    ||      |||____________W5____________|||
    ||__W2__||_____________W3_____________ |
    |__________________W1__________________|

@end group
@end smallexample

Finally, evaluating @code{(split-window W6 nil t)} should get us the
desired configuration as depicted below.
@smallexample
@group
     ______________________________________
    | ______  ____________________________ |
    ||      || __________________________ ||
    ||      ||| ___________  ___________ |||
    ||      ||||           ||           ||||
    ||      ||||           ||           ||||
    ||      ||||_____W6____||_____W7____||||
    ||      |||____________W4____________|||
    ||      || __________________________ ||
    ||      |||                          |||
    ||      |||____________W5____________|||
    ||__W2__||_____________W3_____________ |
    |__________________W1__________________|

@end group
@end smallexample

The scenario sketched above is the standard way to obtain the desired
configuration.  In Emacs 23 it was also the only way to do that since
Emacs 23 did't allow splitting internal windows.

With Emacs 24 you can also proceed as follows: Split an initial window
@code{W6} by evaluating @code{(split-window W6 -3)} to produce the
following vertical combination:
@smallexample
@group
     ______________________________________
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||_________________W6_________________||
    | ____________________________________ |
    ||                                    ||
    ||_________________W5_________________||
    |__________________W3__________________|

@end group
@end smallexample

Evaluating now @code{(split-window (window-parent W6) -8 'left)} or,
equivalently, @code{(split-window W3 -8 'left)} should produce the
familiar configuration
@smallexample
@group
     ______________________________________
    | ______  ____________________________ |
    ||      || __________________________ ||
    ||      |||                          |||
    ||      |||                          |||
    ||      |||                          |||
    ||      |||                          |||
    ||      |||                          |||
    ||      |||____________W6____________|||
    ||      || __________________________ ||
    ||      |||                          |||
    ||      |||____________W5____________|||
    ||__W2__||_____________W3_____________ |
    |__________________W1__________________|

@end group
@end smallexample

from where we can continue as described in the previous scenario.

   Another strategy starts with splitting an inital window @code{W6} by
evaluating @code{(split-window W6 nil nil t)} with the following result:
@smallexample
@group
     ______________________________________
    | _________________  _________________ |
    ||                 ||                 ||
    ||                 ||                 ||
    ||                 ||                 ||
    ||                 ||                 ||
    ||                 ||                 ||
    ||                 ||                 ||
    ||                 ||                 ||
    ||                 ||                 ||
    ||                 ||                 ||
    ||                 ||                 ||
    ||________W6_______||________W7_______||
    |__________________W4__________________|

@end group
@end smallexample

Evaluating now @code{(split-window W4 -3)} or @code{(split-window
(window-parent W6) -3)} should get us a configuration as shown next.
@smallexample
@group
     ______________________________________
    | ____________________________________ |
    || ________________  ________________ ||
    |||                ||                |||
    |||                ||                |||
    |||                ||                |||
    |||                ||                |||
    |||                ||                |||
    |||_______W6_______||________W7______|||
    ||_________________W4_________________||
    | ____________________________________ |
    ||                                    ||
    ||_________________W5_________________||
    |__________________W3__________________|

@end group
@end smallexample

The desired configuration can be now obtained by evaluating
@code{(split-window W3 -8 'left)} or, equivalently, @code{(split-window
(window-parent W5) -8 'left)}.

   For a final approach let's start with the configuration of two live
windows @code{W6} and @code{W7} shown above.  If we now evaluate
@code{(split-window W4 -8 'left)} or @code{(split-window (window-parent
W6) -8 'left)} we get the following configuration.
@smallexample
@group
     ______________________________________
    | ______  ____________________________ |
    ||      || ____________  ____________ ||
    ||      |||            ||            |||
    ||      |||            ||            |||
    ||      |||            ||            |||
    ||      |||            ||            |||
    ||      |||            ||            |||
    ||      |||            ||            |||
    ||      |||            ||            |||
    ||      |||______W6____||______W7____|||
    ||__W2__||_____________W4_____________||
    |__________________W1__________________|

@end group
@end smallexample

Evaluating now @code{(split-window W4 -3)} or, for example,
@code{(split-window (window-parent W6) -3)} should produce the desired
configuration.

  The following option affects the behavior of a number of functions
operating on a window that is part of a window combination, see
@ref{Windows and Frames}.

@defopt window-splits
If this variable is @code{nil}, @code{split-window} creates a new parent
window if and only if either @var{window} has no parent window or
@var{window} shall be split in another direction than the combination
@var{window} is part of.  Moreover, @code{resize-window} tries to resize
@var{window}'s right sibling first and @code{delete-window} preferably
returns space to @var{window}'s left sibling.

   If this variable equals @code{nest}, @code{split-window} always
creates a new parent window.  As a consequence, any frame's window tree
is a binary tree and every window has at most one (left or right)
sibling.  Also, @code{resize-window} preferably resizes @var{window}'s
sibling and @code{delete-window} preferably returns space to
@var{window}'s sibling.  Functions that create atomic windows
(@pxref{Atomic Windows}) bind this variable temporarily to @code{nest}
in order to make sure that subwindows stay glued together.

   If this variable equals @code{resize}, @code{split-window} tries to
resize all windows belonging to the same combination as @var{window} to
accomodate the new window.  Hence, the new window can be also created if
@var{window} is too small to be split.  Resizing or deleting any window
of a combination tries to distribute space proportionally among all
other windows of the combination.

   As a rule, application should not bind this variable to any value but
@code{nest}.  Occasionally, it might make sense to bind this variable to
@code{resize}, for example, when showing a large number of buffers
simultaneously on the same frame.
@end defopt

@deffn Command split-window-vertically &optional size
This function splits the selected window into two windows, one above the
other, leaving the upper of the two windows selected, with @var{size}
lines.  (If @var{size} is negative, then the lower of the two windows
gets @minus{}@var{size} lines and the upper window gets the rest, but
the upper window is still the one selected.)  However, if
@code{split-window-keep-point} (see below) is @code{nil}, then either
window can be selected.

   In other respects, this function is similar to @code{split-window}.
In particular, the upper window is the original one and the return value
is the new, lower window.
@end deffn

@defopt split-window-keep-point
If this variable is non-@code{nil} (the default), then
@code{split-window-vertically} behaves as described above.

   If it is @code{nil}, then @code{split-window-vertically} adjusts
point in each of the two windows to avoid scrolling.  (This is useful on
slow terminals.)  It selects whichever window contains the screen line
that point was previously on.

   This variable affects the behavior of @code{split-window-vertically}
only.  It has no effect on the other functions described here.
@end defopt

@deffn Command split-window-horizontally &optional size
This function splits the selected window into two windows
side-by-side, leaving the selected window on the left with @var{size}
columns.  If @var{size} is negative, the rightmost window gets
@minus{}@var{size} columns, but the leftmost window still remains
selected.
@end deffn


@node Deleting Windows
@section Deleting Windows
@cindex deleting windows

A window remains visible on its frame unless you @dfn{delete} it by
calling certain functions that delete windows.  A deleted window cannot
appear on the screen, but continues to exist as a Lisp object until
there are no references to it.  There is no way to cancel the deletion
of a window aside from restoring a saved window configuration
(@pxref{Window Configurations}).  Restoring a window configuration also
deletes any windows that aren't part of that configuration.  Erroneous
information may result from using a deleted window as if it were live.

@deffn Command delete-window &optional window
This function removes @var{window} from display and returns @code{nil}.
The argument @var{window} can denote any window and defaults to the
selected one.  An error is signaled if @var{window} is the only window
on its frame.  Hence @var{window} must have at least one sibling window
(@pxref{Windows and Frames}) in order to get deleted.

If @code{window-splits} is @code{nil}, the space @var{window} took up is
given to its left sibling if such a window exists and to its right
sibling otherwise.  If @code{window-splits} equals @code{nest} that
space is given to the remaining sibling of @var{window}.  If
@code{window-splits} equals @code{resize}, the space occupied by
@var{window} is proportionally distributed among the remaining windows
in the same combination.

If @code{ignore-window-parameters} (@pxref{Window Parameters}) is
non-@code{nil}, this function ignores window parameters.  Otherwise, if
the @code{delete-window-function} parameter of @var{window} is @code{t},
it deletes the window disregarding other window parameters.  If the
@code{delete-window-function} parameter specifies a function, that
function is called with @var{window} as its sole argument.

If @var{window} is part of an atomic window (@pxref{Atomic Windows}),
this function is called with the root of the atomic window as its
argument.  If that window is the root window of its frame, an error is
signalled.  If @var{window} is the last non-side window on its frame
(@pxref{Side Windows}), this function signals an error too.
@end deffn

@deffn Command delete-other-windows &optional window
This function makes @var{window} fill its frame and returns @code{nil}.
The argument @var{window} can denote an arbitrary window and defaults to
the selected one.

If @code{ignore-window-parameters} (@pxref{Window Parameters}) is
non-@code{nil}, this function ignores window parameters.  Otherwise, if
the @code{delete-other-windows-function} parameter equals @code{t}, it
deletes all other windows disregarding any remaining window parameters.
If the @code{delete-other-windows-function} parameter specifies a
function, it calls that function with @var{window} as its sole argument.

If @var{window} is part of an atomic window (@pxref{Atomic Windows}), it
calls this function with the root of the atomic window as its argument.
If @var{window} is a non-side window (@pxref{Side Windows}), it makes
@var{window} the only non-side window on its frame and leaves side
windows alone.  If @var{window} is a side window, this function signals
an error.
@end deffn

@deffn Command delete-windows-on &optional buffer-or-name frame
This function deletes all windows showing @var{buffer-or-name} and
returns nil.  If there are no windows showing @var{buffer-or-name}, it
does nothing.  The optional argument @var{buffer-or-name} may be a
buffer or the name of an existing buffer and defaults to the current
buffer.  Invoking this command on a minibuffer signals an error.

The function @code{delete-windows-on} operates by calling
@code{delete-window} for each window showing @var{buffer-or-name}.  If a
frame has several windows showing different buffers, then those showing
@var{buffer-or-name} are removed, and the other windows expand to fill
the space.  If all windows in some frame are showing
@var{buffer-or-name} (including the case where there is only one
window), then the frame winds up with a single window showing another
buffer.  If, however, that last remaining window is dedicated to the
buffer specified by @var{buffer-or-name} (@pxref{Dedicated Windows}),
and there are other frames left, that window's frame is deleted.

The optional argument @var{frame} specifies which frames to operate on.
This function does not use it in quite the same way as the other
functions which scan all live windows (@pxref{Cyclic Window Ordering});
specifically, the values @code{t} and @code{nil} have the opposite of
their meanings in the other functions.  Here are the full details:

@itemize @bullet
@item @code{nil}
means operate on all frames.
@item @code{t}
means operate on the selected frame.
@item @code{visible}
means operate on all visible frames.
@item @code{0}
means operate on all visible or iconified frames.
@item A frame
means operate on that frame.
@end itemize
@end deffn


@node Selecting Windows
@section Selecting Windows
@cindex selecting a window

@cindex selected window
In each frame, at any time, one and only one window is designated as
@dfn{selected within the frame}.  Also, at any time, one frame is the
selected frame (@pxref{Input Focus}).  The window selected within the
selected frame is the @dfn{selected window}.  The selected window's
buffer is usually the current buffer (except when @code{set-buffer} has
been used); see @ref{Current Buffer}.

@defun selected-window
This function returns the selected window.  This is the window in which
the cursor for selected windows (@pxref{Cursor Parameters}) appears and
to which many commands apply.
@end defun

@defun select-window window &optional norecord
This function makes @var{window} the selected window.  Unless
@var{window} already is the selected window, this also makes
@var{window}'s buffer (@pxref{Buffers and Windows}) the current buffer.
Moreover, the cursor for selected windows will be displayed in
@var{window} after the next redisplay.  This function returns
@var{window}.

Normally, @var{window}'s selected buffer is moved to the front of the
buffer list (@pxref{The Buffer List}) and @var{window} becomes the most
recently selected window.  But if the optional argument @var{norecord}
is non-@code{nil}, the buffer list remains unchanged and @var{window}
does not become the most recently selected one.
@end defun

@cindex most recently selected windows
The sequence of calls to @code{select-window} with a non-@code{nil}
@var{norecord} argument determines an ordering of windows by their
selection time.  The function @code{get-lru-window} can be used to
retrieve the least recently selected live window in this ordering, see
@ref{Cyclic Window Ordering}.

@defmac save-selected-window forms@dots{}
This macro records the selected frame, as well as the selected window
of each frame, executes @var{forms} in sequence, then restores the
earlier selected frame and windows.  It also saves and restores the
current buffer.  It returns the value of the last form in @var{forms}.

This macro does not save or restore anything about the sizes,
arrangement or contents of windows; therefore, if @var{forms} change
them, the change persists.  If the previously selected window of some
frame is no longer live at the time of exit from @var{forms}, that
frame's selected window is left alone.  If the previously selected
window is no longer live, then whatever window is selected at the end of
@var{forms} remains selected.  The current buffer is restored if and
only if it is still live when exiting @var{forms}.

This macro changes neither the ordering of recently selected windows nor
the buffer list.
@end defmac

@defmac with-selected-window window forms@dots{}
This macro selects @var{window}, executes @var{forms} in sequence, then
restores the previously selected window and current buffer.  The ordering
of recently selected windows and the buffer list remain unchanged unless
you deliberately change them within @var{forms}, for example, by calling
@code{select-window} with argument @var{norecord} @code{nil}.

The order of recently selected windows and the buffer list are not
changed by this macro.
@end defmac

@cindex frame selected window
@cindex window selected within frame
Above we explained that at any time, exactly one window on any frame is
selected within the frame.  The significance of this designation is that
selecting the frame also selects this window.  Conversely, selecting a
window for Emacs with @code{select-window} also makes that window
selected within its frame.

@defun frame-selected-window  &optional frame
This function returns the window on @var{frame} that is selected within
@var{frame}.  The optional argument @var{frame} must denote a live frame
and defaults to the selected one.
@end defun

@defun set-frame-selected-window frame window &optional norecord
This function sets the selected window of frame @var{frame} to
@var{window}.  The argument @var{frame} must denote a live frame and
defaults to the selected one.  If @var{frame} is the selected frame,
this also makes @var{window} the selected window.  The argument
@var{window} must denote a live window.  This function returns
@var{window}.

Optional argument @var{norecord} non-@code{nil} means to neither change
the list of most recently selected windows (@pxref{Selecting Windows})
nor the buffer list (@pxref{The Buffer List}).
@end defun


@node Cyclic Window Ordering
@section Cyclic Ordering of Windows
@cindex cyclic ordering of windows
@cindex ordering of windows, cyclic
@cindex window ordering, cyclic

When you use the command @kbd{C-x o} (@code{other-window}) to select
some other window, it moves through live windows in a specific order.
For any given configuration of windows, this order never varies.  It is
called the @dfn{cyclic ordering of windows}.

   For a particular frame, this ordering is determined by the window
tree of that frame, see @ref{Windows and Frames}.  More precisely, the
ordering is obtained by a depth-first traversal of the frame's window
tree supplemented, if requested, by the frame's minibuffer window.

   If there's just one live frame, the cyclic ordering is the ordering
for that frame.  Otherwise, the cyclic ordering is obtained by appending
the orderings for individual frames in order of the list of all live
frames, @ref{Finding All Frames}.  In any case, the ordering is made
``cyclic'' by having the last window precede the first window in the
ordering.

@defun next-window &optional window minibuf all-frames
@cindex minibuffer window, and @code{next-window}
This function returns the window following @var{window} in the cyclic
ordering of windows.  The argument @var{window} must specify a live
window and defaults to the selected one.

The optional argument @var{minibuf} specifies whether minibuffer windows
shall be included in the cyclic ordering.  Normally, when @var{minibuf}
is @code{nil}, a minibuffer window is included only if it is currently
``active''; this matches the behavior of @kbd{C-x o}.  (Note that a
minibuffer window is active as long as its minibuffer is in use; see
@ref{Minibuffers}).

If @var{minibuf} is @code{t}, the cyclic ordering includes all
minibuffer windows.  If @var{minibuf} is neither @code{t} nor
@code{nil}, minibuffer windows are not included even if they are active.

The optional argument @var{all-frames} specifies which frames to
consider.  Here are the possible values and their meanings:

@itemize @bullet
@item @code{nil}
means consider all windows on @var{window}'s frame, plus the minibuffer
window used by that frame even if it lies in some other frame.  If the
minibuffer counts (as determined by @var{minibuf}), then all windows on
all frames that share that minibuffer count too.

@item @code{t}
means consider all windows on all existing frames.

@item @code{visible}
means consider all windows on all visible frames.  (To get useful
results, ensure that @var{window} is on a visible frame.)

@item 0
means consider all windows on all visible or iconified frames.

@item A frame
means consider all windows on that frame.

@item Anything else
means consider the windows on @var{window}'s frame, and no others.
@end itemize

This example assumes there are two windows, both displaying the
buffer @samp{windows.texi}:

@example
@group
(selected-window)
     @result{} #<window 56 on windows.texi>
@end group
@group
(next-window (selected-window))
     @result{} #<window 52 on windows.texi>
@end group
@group
(next-window (next-window (selected-window)))
     @result{} #<window 56 on windows.texi>
@end group
@end example
@end defun

@defun previous-window &optional window minibuf all-frames
This function returns the window preceding @var{window} in the cyclic
ordering of windows.  The other arguments specify which windows to
consider as in @code{next-window}.
@end defun

@deffn Command other-window count &optional all-frames
This function selects another window in the cyclic ordering of windows.
@var{count} specifies the number of windows to skip in the ordering,
starting with the selected window, before making the selection.  If
@var{count} is a positive number, it skips @var{count} windows forwards.
@var{count} negative means skip @minus{}@var{count} windows backwards.
If @var{count} is zero, it does not skip any window, thus re-selecting
the selected window.  In an interactive call, @var{count} is the numeric
prefix argument.

The optional argument @var{all-frames} has the same meaning as in
@code{next-window}, but the @var{minibuf} argument of @code{next-window}
is always effectively @code{nil}.  This function returns @code{nil}.

This function does not select a window that has a non-@code{nil}
@code{no-other-window} window parameter (@pxref{Window Parameters}).
@end deffn

The following function returns a copy of the list of windows in the
cyclic odering.

@defun window-list-1 &optional window &optional minibuf &optional all_frames
This function returns a list of live windows.  The optional arguments
@var{minibuf} and @var{all-frames} specify the set of windows to include
in the list.  See the description of @code{next-window} for details.

The optional argument @var{window} specifies the first window to list
and defaults to the selected window.  If @var{window} is not on the list
of windows returned, some other window will be listed first but no error
is signalled.
@end defun

The functions described below use @code{window-list-1} for generating a
copy of the list of all relevant windows.  Hence, any change of the
window configuration that occurs while one of these functions is
executed is @emph{not} reflected in the list of windows investigated.

@defun walk-windows proc &optional minibuf all-frames
This function cycles through live windows.  It calls the function
@var{proc} once for each window, with the window as its sole argument.

The optional arguments @var{minibuf} and @var{all-frames} specify the
set of windows to include in the walk, see @code{next-window} above.  If
@var{all-frames} specifies a frame, the first window walked is the first
window on that frame as returned by @code{frame-first-window} and not
necessarily the selected window.

If @var{proc} changes the window configuration by splitting or deleting
windows, that change is not reflected in the set of windows walked.
That set is determined entirely by the set of live windows at the time
this function was invoked.
@end defun

The following function allows to determine whether a specific window is
the only live window.

@defun one-window-p &optional no-mini all-frames
This function returns non-@code{nil} if the selected window is the only
window.

The optional argument @var{no-mini}, if non-@code{nil}, means don't
count the minibuffer even if it is active; otherwise, the minibuffer
window is counted when it is active.  The optional argument
@var{all-frames} has the same meaning as for @code{next-window}, see
above.
@end defun

@cindex finding windows
  The following functions choose (but do not select) one of the windows
on the screen, offering various criteria for the choice.

@cindex least recently used window
@defun get-lru-window &optional all-frames dedicated
This function returns the window least recently ``used'' (that is,
selected).  If any full-width windows are present, it only considers
these.  The optional argument @var{all-frames} has the same meaning as
in @code{next-window}.

The selected window is returned if it is the only candidate.  A
minibuffer window is never a candidate.  A dedicated window
(@pxref{Dedicated Windows}) is never a candidate unless the optional
argument @var{dedicated} is non-@code{nil}.
@end defun

@cindex largest window
@defun get-largest-window &optional all-frames dedicated
This function returns the window with the largest area (height times
width).  If there are no side-by-side windows, then this is the window
with the most lines.  A minibuffer window is never a candidate.  A
dedicated window (@pxref{Dedicated Windows}) is never a candidate unless
the optional argument @var{dedicated} is non-@code{nil}.

If there are two candidate windows of the same size, this function
prefers the one that comes first in the cyclic ordering of windows,
starting from the selected window.

The optional argument @var{all-frames} specifies which set of windows to
consider as with @code{next-window}, see above.
@end defun

@cindex window that satisfies a predicate
@cindex conditional selection of windows
@defun get-window-with-predicate predicate &optional minibuf all-frames default
This function returns a window satisfying @var{predicate}.  It cycles
through all visible windows calling @var{predicate} on each one of them
with that window as its argument.  The function returns the first window
for which @var{predicate} returns a non-@code{nil} value; if that never
happens, it returns @var{default} (which defaults to @code{nil}).

The optional arguments @var{minibuf} and @var{all-frames} specify the
set of windows to investigate.  See the description of
@code{next-window} for details.
@end defun


@node Buffers and Windows
@section Buffers and Windows
@cindex examining windows
@cindex windows, controlling precisely
@cindex buffers, controlled in windows

To find out which buffer is displayed in a given window the following
function is used.

@defun window-buffer &optional window
This function returns the buffer that @var{window} is displaying.  The
argument @var{window} can be any window and defaults to the selected
one.  If @var{window} is an internal window, this function returns
@code{nil}.
@end defun

The basic, low-level function to associate a window with a buffer is
@code{set-window-buffer}.  Higher-level functions like
@code{display-buffer} try to obey a number of user customizations
regulating which windows are supposed to display which buffers.  When
writing an application, programmers should therefore carefully evaluate
whether they really need the power of this @code{set-window-buffer}.

@defun set-window-buffer window buffer-or-name &optional keep-margins
This function makes @var{window} display @var{buffer-or-name} and
returns @code{nil}.  The argument @var{window} has to denote a live
window and defaults to the selected one.  The argument
@var{buffer-or-name} must specify a buffer or the name of an existing
buffer.

Normally, displaying @var{buffer-or-name} in @var{window} resets the
window's position, display margins, fringe widths, and scroll bar
settings based on the local variables of the specified buffer.  However,
if the optional argument @var{keep-margins} is non-@code{nil}, display
margins and fringe widths of @var{window} remain unchanged.
@xref{Fringes}.

@code{set-window-buffer} is the fundamental primitive for changing which
buffer is displayed in a window, and all ways of doing that call this
function.  Neither the selected window nor the current buffer are
changed by this function.

@code{set-window-buffer} signals an error when @var{window} is
@dfn{strongly} dedicated to its buffer (@pxref{Dedicated Windows}) and
does not already display @var{buffer-or-name}.

This function runs @code{window-scroll-functions} before running
@code{window-configuration-change-hook}, see @ref{Window Hooks}.
@end defun

@defvar buffer-display-count
This buffer-local variable records the number of times a buffer has been
displayed in a window.  It is incremented each time
@code{set-window-buffer} is called for the buffer.
@end defvar

@defvar buffer-display-time
This variable records the time at which a buffer was last made visible
in a window.  It is always local in each buffer; each time
@code{set-window-buffer} is called, it sets this variable to
@code{(current-time)} in the specified buffer (@pxref{Time of Day}).
When a buffer is first created, @code{buffer-display-time} starts out
with the value @code{nil}.
@end defvar

@defun get-buffer-window &optional buffer-or-name all-frames
This function returns a window displaying @var{buffer-or-name}, or
@code{nil} if there is none.  If there are several such windows, then
the function returns the first one in the cyclic ordering of windows,
starting from the selected window, @xref{Cyclic Window Ordering}.

The argument @var{BUFFER-OR-NAME} may be a buffer or a buffer name and
defaults to the current buffer.  The optional argument @var{all-frames}
specifies which windows to consider:

@itemize @bullet
@item
@code{nil} means consider windows on the selected frame.
@item
@code{t} means consider windows on all existing frames.
@item
@code{visible} means consider windows on all visible frames.
@item
0 means consider windows on all visible or iconified frames.
@item
A frame means consider windows on that frame only.
@end itemize

Observe that the behavior of @code{get-buffer-window} may differ from
that of @code{next-window} (@pxref{Cyclic Window Ordering}) when
@var{all-frames} equals @code{nil} or any value not listed here.
Perhaps we will change @code{get-buffer-window} in the future to make it
compatible with the other functions.
@end defun

@defun get-buffer-window-list &optional buffer-or-name minibuf all-frames
This function returns a list of all windows currently displaying
@var{buffer-or-name}.  The argument @var{buffer-or-name} may be a buffer
or the name of an existing buffer and defaults to the current buffer.

The two remaining arguments work like the same-named arguments of
@code{next-window} (@pxref{Cyclic Window Ordering}); they are @emph{not}
like the optional arguments of @code{get-buffer-window}.
@end defun

The following command removes a buffer from all windows showing it.

@deffn Command replace-buffer-in-windows &optional buffer-or-name
This function replaces @var{buffer-or-name} in all windows displaying it
with some other buffer.  It uses @code{switch-to-prev-buffer}, see
below, to choose that other buffer which is usually the last buffer
displayed before @var{buffer-or-name} in the respective window.

The argument @var{buffer-or-name} may be a buffer or the name of an
existing buffer and defaults to the current buffer.

If a window displaying @var{buffer-or-name} is dedicated
(@pxref{Dedicated Windows}), and is not the only window on its frame,
that window is deleted.  If that window is the only window on its frame
and there are other frames left, the window's frame is deleted too.  If
there are no other frames left, some other buffer is displayed in that
window as explained above.

This function returns @code{nil}.
@end deffn

   When @code{replace-buffer-in-windows} has to show another buffer in a
window, it tries to pick the buffer shown there before.  For this
purpose each window remembers the buffers it has displayed earlier and
the order in which these buffers have been removed from it.

The list of @dfn{previous buffers} of a window is an association list
where each entry specifies a buffer, the last start position of that
buffer in the window (@pxref{Window Start and End}) and the last
position of that buffer's point in the window (@pxref{Window Point}).
This list is ordered by the times of the removal of the respective
buffers from the window.  In particular, the first element of the list
references the buffer removed most recently.  The function
@code{set-window-buffer} pushes an entry for the old buffer of its
window argument on that list before it shows its buffer argument in the
window.

The list of @dfn{next buffers} of a window is a list of buffers that
have been recently re-shown by the function @code{switch-to-prev-buffer}
and is used to avoid that that function switches to such a buffer again
before showing other interesting buffers.

The lists of previous and next buffers and the global buffer list
(@pxref{The Buffer List}) allow to effectively display all buffers in a
window while giving preference to the buffers previously shown in that
window.  The commands used for this purpose are
@code{switch-to-prev-buffer} and @code{switch-to-next-buffer} described
below.

The following functions directly operate on the lists of previous and
next buffers.

@defun window-prev-buffers &optional window
This function returns an alist specifying the buffers previously shown
in @var{window} together with their window start and point positions.
The argument @var{window} must be a live window and defaults to the
selected one.
@end defun

@defun set-window-prev-buffers window prev-buffers
This function sets @var{window}'s previous buffers to the value of
@var{prev-buffers}.  The argument @var{window} must be a live window and
defaults to the selected one.  This function returns
@var{prev-buffers}.

If non-@code{nil}, @var{prev-buffers} must specify an alist of triples
specifying a buffer and two markers for that buffer's start and point
position in @var{window}.
@end defun

@defun window-next-buffers &optional window
This function returns the list of buffers recently re-shown in
@var{window}.  The argument @var{window} must be a live window and
defaults to the selected one.
@end defun

@defun set-window-next-buffers window next-buffers
This function sets @var{window}'s next buffers to @var{next-buffers}.
@var{window} must be a live window and defaults to the selected one.
This fucntion returns @var{next-buffers}.

If non-@code{nil}, the argument @var{next-buffers} should specify a list
of buffers that shall be preferably not shown by the command
@code{switch-to-prev-buffer}, see below.
@end defun

The following command is used by @code{replace-buffer-in-windows},
@code{bury-buffer} and @code{quit-restore-window} to show another buffer
in a window.  It can be also used interactively to cycle through the
list of all buffers in a window, preferably showing the buffers recently
shown (but not buried or killed) in that window.

@deffn Command switch-to-prev-buffer &optional window bury-or-kill
This function displays the previous buffer in @var{window}.  The
argument @var{window} must be a live window and defaults to the selected
one.  If the optional argument @var{bury-or-kill} is non-@code{nil},
this means that the buffer currently shown in @var{window} is about to
be buried or killed and consequently shall not be switched to in future
invocations of this command.

The previous buffer is usually the buffer shown before the buffer
currently shown in @var{window}.  However, a buffer that has been buried
or killed or has been already shown by a recent invocation of
@code{switch-to-prev-buffer} does not qualify as previous buffer.

If repeated invocations of this command have already shown all buffers
previously shown in @var{window}, further invocations will show buffers
from the global buffer list starting with the buffer returned by
@code{last-buffer} (@pxref{The Buffer List}).
@end deffn

The following command can be used to undo the effect of the last undone
@code{switch-to-prev-buffer} command.

@deffn Command switch-to-next-buffer &optional window
This functions switches to the next buffer in @var{window} thus undoing
the effect of the last @code{switch-to-prev-buffer} command in
@var{window}.  The argument @var{window} must be a live window and
defaults to the selected one.

If there is no recent invocation of a @code{switch-to-prev-buffer} that
can be undone, @code{switch-to-next-buffer} will try to show the first
buffer from the global buffer list as returned by @code{other-buffer}
(@pxref{The Buffer List}).
@end deffn

   Together, @code{switch-to-prev-buffer} and
@code{switch-to-next-buffer} permit to navigate the global buffer list
much like @code{bury-buffer} and @code{unbury-buffer}.  In contrast with
the latter, however, they may show a buffer even if it is already shown
in another window.  Moreover, they try to restore the window specific
start and point positions of buffers which should handle viewing one and
the same buffer in multiple windows more easily.


@node Displaying Buffers
@section Choosing a Window for Displaying a Buffer

The basic facility to choose a window and display a buffer in it is
@code{display-buffer}.  Many higher-level functions like
@code{pop-to-buffer} (@pxref{Switching Buffers}) and
@code{with-output-to-temp-buffer} (@pxref{Temporary Displays}) work by
calling this function.  Here we describe how @code{display-buffer}
works, how to customize its behavior, and how to get rid of the chosen
window once it is no more needed.

@deffn Command display-buffer &optional buffer-or-name specifiers label
This command makes the buffer specified by @var{buffer-or-name} appear
in some window, but it does not necessarily select that window or make
the buffer current.  It returns the window chosen to display the buffer,
@code{nil} if no such window can be found.

The optional argument @var{buffer-or-name} has to specify a buffer or
the name of a buffer and defaults to the current buffer.  If
@var{buffer-or-name} is a string that does not name an existing buffer,
@code{display-buffer} creates a buffer with that name.  When called
interactively, it prompts for a buffer name in the minibuffer.

The optional argument @var{specifiers} is usually a list of buffer
display specifiers, see the description of @code{display-buffer-alist}
below.  For convenience, @var{specifiers} may also consist of a single
macro specifier or @code{t}, where the latter means to display the
buffer in any but the selected window.  If @var{specifiers} is
@code{nil} or omitted, this means to exclusively use the values provided
by the variable @code{display-buffer-alist}.  If that variable is nil
too, default specifiers are used.

The optional third argument @var{label}, if non-@code{nil}, is a symbol
specifying the buffer display label.  Applications should set this when
the buffer shall be displayed in some special way but
@var{buffer-or-name} alone does not identify the buffer as special.
Typical buffers that fit into this category are those whose names are
derived from the name of the file they are visiting.  A user can then
override @var{specifiers} by adding an entry to
@code{display-buffer-alist} whose @sc{car} contains @var{label} and
whose @sc{cdr} specifies the preferred alternative display method.
@end deffn                                                                      

Precisely how @code{display-buffer} finds or creates a window depends on
the @var{specifiers} argument and the two variables described next.

@defopt display-buffer-alist
@cindex buffer identifier
The value of this option is a list associating buffer identifiers with
buffer display specifiers.  The @sc{car} of each element of this list is
built from cons cells called @dfn{buffer identifiers}.  The function
@code{display-buffer} shows a buffer according to the display specifiers
in the element's @sc{cdr} (elements are true lists) if at least one of
these buffer identifiers matches the first or third argument of
@code{display-buffer}.  Such a match occurs in one of the following
three cases:

@itemize @bullet
@item
The @sc{car} of the buffer identifier is the symbol @code{name} and its
@sc{cdr} is a string equalling the name of the buffer specified by the
@var{buffer-or-name} argument of @code{display-buffer}.

@item
The @sc{car} is the symbol @code{regexp} and the @sc{cdr} is a regular
expression matching the name of the buffer specified by the first
@var{buffer-or-name} argument of @code{display-buffer}.

@item
The @sc{car} is the symbol @code{label} and the @sc{cdr} is a symbol
equalling the @var{label} argument of @code{display-buffer}.
@end itemize

@cindex buffer display specifier
@cindex method specifier
A @dfn{buffer display specifier} is a symbol, a cons cell, or a list,
telling @code{display-buffer} where and how to display a given buffer.
Four specifiers allow to indicate the basic method for displaying the
buffer: @code{reuse-window}, @code{pop-up-window}, @code{pop-up-frame}
and @code{use-side-window}.

   A list whose @sc{car} is the symbol @code{reuse-window} indicates
that an existing window shall be reused for displaying the buffer.  The
second element of this list specifies the window to reuse and can be one
of the following symbols:

@itemize @bullet
@item
@code{nil} stands for any window.

@item
@code{same} stands for the selected window.

@item
@code{other} stands for any but the selected window.
@end itemize

The third element specifies whether the buffer shown in the window that
shall be reused must be the same buffer that shall be displayed or
another buffer and can be one of the following:

@itemize @bullet
@item
@code{nil} means to not care about the window's buffer.

@item
@code{same} means the window must show the buffer already.

@item
@code{other} means the window must not show the buffer yet.
@end itemize

The fourth element specifies the set of frames to search for a suitable
window and can be one of the following:

@itemize @bullet
@item
@code{nil} to stay on the selected frame.

@item
@code{visible} to search visible frames only.

@item
@code{other} stands for any visible frame but the selected one.

@item
0 (the number zero) to search visible and iconified frames.

@item
@code{t} to search arbitrary frames including invisible ones.
@end itemize

If more than one window fits the constraints imposed by these elements,
the least recently used among them is chosen.  A side window
(@pxref{Side Windows}) is reused if and only if it already shows the
buffer that shall be displayed.

Two specifiers are useful when the method equals @code{reuse-window}:

@itemize @bullet
@item
A cons cell whose @sc{car} is the symbol @code{reuse-window-even-sizes}
and whose @sc{cdr} is non-@code{nil} means to even out the sizes of the
reused and the selected window provided they (1) are adjacent to each
other and (2) the selected window is larger than the window chosen.  If
the @sc{cdr} is @code{nil}, this means that the window sizes are left
alone.

@item
A cons cell whose @sc{car} is the symbol @code{reuse-window-dedicated}
and whose @sc{cdr} is non-@code{nil} means that a window can be reused
even if it's dedicated to its buffer.  If the @sc{cdr} is @code{t}, a
strongly dedicated window can be reused to show the buffer.  Any other
non-@code{nil} value means only weakly dedicated windows can be reused.
If the @sc{cdr} is @code{nil}, dedicated windows are not reused.

This specifier should be used in special cases only since windows are
usually made dedicated in order to prevent @code{display-buffer} from
reusing them.
@end itemize

A list whose @sc{car} is the symbol @code{pop-up-window} and whose
@sc{cdr} is built from window/side tuples indicates that a new window
shall be made for displaying the buffer on the selected frame.

Window/side tuples are cons cells.  The @sc{car} of such a tuple
identifies the window that shall be split.  Possible values are
@code{largest}, @code{lru}, @code{selected}, and @code{root} to
respectively split the largest, least recently used, selected or root
window of the selected frame.

The @sc{cdr} of each pair specifies on which side of the window to split
the new window shall appear and can be one of @code{below},
@code{right}, @code{above}, or @code{left} with the obvious meanings.
If the @sc{cdr} is @code{nil}, the window is split in a fashion suitable
for its current dimensions.  If the @sc{cdr} specifies a function, that
function is called with one argument---the window that shall be split.
The function is supposed to split that window and return the new window.

The function @code{display-buffer} scans these tuples until it can
either produce a suitable window or fails.  The default value for
@code{display-buffer-alist} contains the tuples

@smallexample
(largest . nil) (lru . nil)
@end smallexample

in order to split the largest window first and, if that fails, the least
recently used one.

The following additional specifiers are useful with the
@code{pop-up-window} method specifier.

@itemize @bullet
@item
A cons cell whose @sc{car} is the symbol @code{pop-up-window-min-height}
specifies the minimum height of the new window.  If the @sc{cdr} is an
integer number, it specifies the minimum number of lines of the window.
A floating point number gives the minimum fraction of the window height
with respect to the height of the frame's root window.  A new window is
created only if it can be made at least as high as specified by the
number.  If the @sc{cdr} is @code{nil}, this means to use the value of
@code{window-min-height}.

@item
A cons cell whose @sc{car} is the symbol @code{pop-up-window-min-width}
specifies the minimum width of the new window.  If the @sc{cdr} is an
integer number, it specifies the minimum number of columns of the
window.  A floating point number gives the minimum fraction of the
window width with respect to the width of the frame's root window.  A
new window is created only if it can be made at least as wide as
specified by the number.  If the @sc{cdr} is @code{nil}, the value of
@code{window-min-width} is used.

@item
A cons cell whose @sc{car} is @code{pop-up-window-set-height} with
the following interpretations for the @sc{cdr}:

@itemize @minus
@item
@code{nil} means leave the height of the new window alone.

@item
A number specifies the desired height of the new window.  An integer
number specifies the number of lines of the window.  A floating point
number gives the fraction of the window's height with respect to the
height of the frame's root window.

@item
If the @sc{cdr} specifies a function, that function is called with one
argument - the new window.  The function is supposed to adjust the
height of the window; its return value is ignored.  Suitable functions
to call here are @code{shrink-window-if-larger-than-buffer} and
@code{fit-window-to-buffer}, see @ref{Resizing Windows}.
@end itemize

@item
A cons cell whose @sc{car} equals @code{pop-up-window-set-width}
with the following interpretations for the cdr:

@itemize @minus
@item
@code{nil} means leave the width of the new window alone.

@item
A number specifies the desired width of the new window.  An integer
number specifies the number of columns of the window.  A floating point
number gives the fraction of the window's width with respect to the
width of the frame's root window.

@item
If the @sc{cdr} specifies a function, that function is called with one
argument - the new window.  The function is supposed to adjust the width
of the window; its return value is ignored.
@end itemize

Observe that specifying @code{pop-up-window-set-height} and
@code{pop-up-window-set-width} may override restrictions given by the
@code{pop-up-window-min-height} and @code{pop-up-window-min-width}
specifiers.

@item
A cons cell whose @sc{car} is @code{pop-up-window-split-unsplittable}
and whose @sc{cdr} is non-@code{nil} allows to make a new window on an
unsplittable frame.  If the @sc{cdr} is @code{nil}, unsplittable frames
are not split.  This specifier should be used in special cases only
since frames are usually made unsplittable in order to prevent
@code{display-buffer} from splitting them.
@end itemize

A list of two elements whose @sc{car} is the symbol @code{pop-up-frame}
states that a new frame shall be made for displaying the buffer.  The
second element of this list, if non-nil, allows to make a new frame on
graphic displays only.

The following additional specifiers are useful with the
@code{pop-up-frame} method specifier.

@itemize @bullet
@item
A list whose @sc{car} is the symbol @code{popup-frame-function} together
with a valid function as @sc{cdr} specifies the function for creating a
new frame.  If the @sc{cdr} is @code{nil}, the default function
@code{make-frame} is called.  The function is called with the parameters
and values provided by the specifier described next.

@item
A list whose @sc{car} is the symbol @code{popup-frame-alist} followed by
an arbitrary number of frame parameter/value tuples, each given as a
cons cell, specifies the parameters passed to the popup frame function.
@end itemize

A list of three elements whose @sc{car} is the symbol
@code{use-side-window} specifies that the buffer shall be displayed in a
side window (@pxref{Side Windows}) of the selected frame.  The second
element denotes the side of the frame where the window shall appear and
must be one of @code{left}, @code{top}, @code{right} and @code{bottom}.
If no window on the specified side exists yet, @code{display-buffer}
creates one.

The third element is a number and denotes the slot within the specified
side.  Slots are numbers where the number zero stands for the window in
the middle of the side.  A slot less than zero indicates that the window
shall be shown on the left (for the top and bottom side window) or above
(for the left and right side window) of the window in the middle.  A
slot larger than zero indicates that the window shall be shown on the
right (for the top and bottom side window) or below (for the left and
right side window) of the window in the middle.

If a side window with the specified slot exists already and is not
dedicated to its buffer, @code{display-buffer} reuses that window.  If
no such window exists, @code{display-buffer} tries to make a new window
with the specified slot by splitting the side window with the nearest
matching slot.  If creating a new side window is impossible,
@code{display-buffer} tries to reuse the side window with the nearest
matching slot.  The option @code{window-sides-slots} (@pxref{Side
Windows}) can be used to restrict the number of windows on each side.

In conjunction with the @code{use-side-window} method specifier, the
specifiers @code{reuse-window-dedicated},
@code{pop-up-window-min-height}, @code{pop-up-window-min-width},
@code{pop-up-window-set-height} and @code{pop-up-window-set-width}
described above can be used.

A list whose @sc{car} is the symbol @code{fun-with-args} specifies that
the buffer shall be displayed by the function that appears as second
element of that list.  The third element is a list of arguments that are
passed as second argument to that function---the first argument is the
buffer that shall be displayed.  The function is not passed any
specifiers.

The function shoul choose or create a window, display the specified
buffer in it, and return the window.  It is also responsible for giving
the variable @code{display-buffer-window} a meaningful value, see below
for an explanation.  Moreover, the function should set up the
@code{quit-restore} window parameter which is required for proper
functioning of the command @code{quit-restore-window}, see below.

It's hardly a good idea to call @code{display-buffer} within the body of
the function specified here since this may lead to infinite recursion.

@cindex macro specifier
Instead of writing method specifiers it's often more convenient to use a
predefined macro specifier.  The following macro specifiers are
provided:

@itemize @bullet
@item
@code{same-frame} to make or use a window on the selected frame.

@item
@code{other-window} to make or use any window but the selected one.

@item
@code{same-frame-other-window} to make or use any window on the
selected frame with exception of the selected window.

@item
@code{other-visible-frame} to make sure the window appears on any
visible frame but the selected one.

@item
@code{default} to use the specifier of the default value of
@code{display-buffer-alist} as described below.
@end itemize

In addition it's possible to specify whether the window chosen shall
become dedicated to the buffer (@pxref{Dedicated Windows}).  This is
accomplished with the help of a cons cell whose @sc{car} is the symbol
@code{dedicated} and whose @sc{cdr} is one of the following values:

@itemize @bullet
@item
@code{nil} which means to not dedicate the window to the buffer,

@item
@code{weak} which means the window shall be weakly dedicated to its
buffer, or

@item
@code{t} to strongly dedicate the window to the buffer.
@end itemize

Moreover you can specify whether the function @code{other-window}
(@pxref{Cyclic Window Ordering}) is allowed to select the window used
for displaying the buffer.  This is accomplished with the help of a cons
cell whose @sc{car} is the symbol @code{no-other-window} and whose
@sc{cdr} is non-@code{nil}.

In general, an application is free to ignore the specifiers of
@code{display-buffer-alist} by explicitly passing a non-@code{nil}
second argument to @code{display-buffer}.  For any
@code{display-buffer-alist} entry one can, however, add a cons cell
whose @sc{car} is the symbol @code{override} and whose @sc{cdr} is
non-@code{nil} to explicitly override the value supplied by the
application.

Overriding arguments supplied by the calling application is, in general,
not advisable.  It permits, for example, to change the semantics of
commands like @code{switch-to-buffer-other-window} by setting the method
specifier to @code{same-window} or @code{other-frame}.
@end defopt

The value of @code{display-buffer-alist} may contain scalar elements
which are used by the customization interface and are ignored by
@code{display-buffer}.  The normalized default specifiers are:

@example
 ((reuse-window nil same visible)
  (pop-up-window (largest) (lru))
  (pop-up-frame)
  (reuse-window nil other visible)
  (reuse-window-even-sizes . t))
@end example

It means to proceed as follows:

@itemize @bullet
@item
First try reusing a window showing the buffer on some visible frame.  If
a window above or below the selected window is reused, the sizes of
those windows are evened out.

@item
Next try to pop up a window on the selected frame by splitting either
the largest or the least recently used window in a system dependent way.

@item
Try to pop up a new frame using the default function @code{make-frame}.

@item
Try to reuse a window showing some other buffer on a visible frame.
@end itemize

If these specifiers fail to produce a suitable window,
@code{display-buffer} uses a number of heuristics that do not
necessarily observe the value of @code{display-buffer-alist}.

An application calling @code{display-buffer} can, in some cases, replace
fixed references to windows or buffers within display specifiers by
references to Lisp objects like windows or buffers.  In particular the
following are possible:

@itemize @bullet
@item
The @code{reuse-window} specifier accepts as second element a live
window and as third element a live buffer.

@item
In window/side tuples of the @code{pop-up-window} specifier an arbitrary
window can be used as first element.
@end itemize

In order to understand how @code{display-buffer} combines the values of
@code{display-buffer-alist} with the @var{specifiers} argument suppose
the following item

@example
(((name . "*text*"))
 ((pop-up-window (selected . below) (root . below))
  (override . t)))
@end example

has been added to @code{display-buffer-alist} and @code{display-buffer}
is called as

@example
(display-buffer "*text*" '((reuse-window same)))
@end example

Since the entry from @code{display-buffer-alist} matches the buffer name
and has the @code{override} specifier set, @code{display-buffer} will
first try to split either the selected or the root window of the
selected frame.

   If neither of these windows can be split, @code{display-buffer} will
try to display the buffer in the selected window as requested by the
@var{specifiers} argument.  If this fails as well, for example, because
the selected window is dedicated to another buffer,
@code{display-buffer} will apply the default specifiers from
@code{display-buffer-alist} as sketched above.  Observe that in this
case @code{display-buffer} will not necessarily try to split the
selected or the frame's root window because the corresponding specifiers
from @code{display-buffer-alist} have been already consumed at that
time.

   So the order of precedence is to try the overriding specifiers from
@code{display-buffer-alist} first.  Next come the specifiers from the
@var{specifiers} argument of @code{display-buffer}.  Finally,
non-overriding specifiers from @code{display-buffer-alist} are tried.

   In case you observe any unexpected behavior of @code{display-buffer}
keep in mind the following:

@itemize @bullet
@item
Specifiers are consumed in the order sketched above, which means that
the value of the first specifier found prevails.  When
@code{display-buffer} applies a method specifier, any specifiers
preceding the method specifier have been consumed already and do no more
affect the work of @code{display-buffer}.

@item
Displaying a buffer on a new or other frame will always raise that frame
and give it input focus.  This contrasts with the behavior of
@code{display-buffer} up to Emacs 22.  While not raising the frame seems
like the correct behavior, it is presently not done due to possible bad
interaction with window managers on various platforms.

@item
The customization interface does not allow to assign every conceivable
value to the option @code{display-buffer-alist}.  You have to set these
by hand to achieve more exotic behavior.
@end itemize

   Next we describe how to manually transcribe the buffer display
options of Emacs 23 with @code{display-buffer-alist}.  For a mechanized
way to do this see the command @code{display-buffer-alist-set} descibed
below.

@itemize @bullet
@item
The options @code{same-window-buffer-names} and
@code{same-window-regexps} are handled by the @code{same-window} macro
specifier.

@item
For @code{display-buffer-reuse-frames} use the @code{reuse-window}
specifier with a non-@code{nil} third element and as fourth element the
set of frames that should be considered.

@item
The options @code{special-display-buffer-names} and
@code{special-display-regexps} are replaced by
@code{display-buffer-alist} itself because, in a sense, all buffers are
special now.

@item
The @code{special-display-function} option is emulated by setting the
@code{pop-up-frame-function} specifier.

@item
The @code{special-display-frame-alist} option is now handled by the
@code{popup-frame-alist} specifier.

@item
The option @code{pop-up-frames} is replaced by the @code{pop-up-frame}
method specifier.

@item
The option @code{pop-up-frame-function} has become the homonymous
specifier.

@item
The option @code{pop-up-frame-alist} has become the homonymous specifier.

@item
The option @code{pop-up-windows} is replaces by the @code{pop-up-window}
method specifier.

@item
A @code{split-window-preferred-function} can be specified as the second
in a window/side tuple of the @code{pop-up-window} specifier.

@item
@code{split-height-threshold} and @code{split-width-threshold} are
handled by the @code{pop-up-window-min-height} and
@code{pop-up-window-min-width} specifiers respectively.  The sizes you
specify there are, however, no more the original sizes of the window to
split but the desired minimum sizes of the new window.

@item
@code{even-window-heights} is handled by setting the @sc{cdr} of the
@code{reuse-window-even-sizes} specifier to a non-@code{nil} value.
@end itemize

@defopt display-buffer-function
This variable is the most flexible way to customize the behavior of
@code{display-buffer}.  If it is non-@code{nil}, it should be a function
that @code{display-buffer} calls to do the work.  The function must
accept two arguments, the buffer to display and a list of normalized
buffer display specifiers as produced by
@code{display-buffer-normalize-specifiers}, see below.

It should choose or create a window, display the specified buffer in it,
and then return the window.  It is also responsible for giving the
variable @code{display-buffer-window} a meaningful value, see below for
an explanation.  Moreover, the function should set up the
@code{quit-restore} window parameter which is required for proper
functioning of the command @code{quit-restore-window}, see below.

The function specified here is free to ignore any specifiers passed to
it as second argument.  If you intend to call @code{display-buffer}
within the body of the function specified here, it's a good idea to bind
@code{display-buffer-function} to @code{nil} around each such call to
avoid running into an infinite recursion.
@end defopt

Above we described how to manually obtain the settings of
@code{display-buffer-alist} from Emacs 23 buffer display options.  The
function described next should do this automatically.

@defun display-buffer-alist-set &optional no-custom add
This fucntion sets @code{display-buffer-alist} from Emacs 23 buffer
display options.  The optional argument @var{no-custom} @code{nil} means
to apply the function @code{customize-set-variable} to set the value of
@code{display-buffer-alist}.  If @var{no-custom} is non-@code{nil}, this
means to use @code{setq} instead.

The optional argument @var{add} @code{nil} means to replace the actual
value of @code{display-buffer-alist} with the value calculated here.  If
@var{add} is non-@code{nil}, this means to prepend the value calculated
here to the current value of @code{display-buffer-alist}.
@end defun

Applications setting or binding Emacs 23 buffer display options will
usually fail to achieve the desired effect if they do not set the
@var{specifiers} argument of @code{display-buffer} accordingly.  Binding
or setting @code{display-buffer-function} to the function sketched below
can bypass this problem until the @var{specifiers} argument has been
rewritten.

@example
(defun my-display-buffer (buffer specifiers)
  "Run `display-buffer' with Emacs 23 buffer display options."
  (let (display-buffer-alist display-buffer-function)
    (display-buffer-alist-set t)
    (display-buffer buffer)))
@end example

The function @code{my-display-buffer} applies
@code{display-buffer-alist-set} to a locally bound, pristine copy of
@code{display-buffer-alist} and calls @code{display-buffer} without any
specifiers.  Note the local binding of @code{display-buffer-function}
which avoids that @code{display-buffer} calls @code{my-display-buffer}
recursively.

   In this context note that the purpose of the buffer display options
of Emacs 23 was to give users an instrument to control the behavior of
how buffers are displayed.  Setting or binding such an option within an
application did constitutes bad programming practice just like setting
or binding @code{display-buffer-alist} would.  Applications are supposed
to @emph{exclusively} use the @var{specifiers} argument in order to
affect the behavior of @code{display-buffer}.

The function @code{display-buffer} tries hard to find a new window for
displaying the buffer and fails (that is, returns @code{nil}) only in
rare cases.  The functions described next are called by
@code{display-buffer} but can be occasionally useful for applications
that want more deterministic behavior.  These functions must be called
with normalized specifiers which means that all macro specifiers must
have been already expanded and the scalar symbols used by the
customization interface removed.  To get normalized specifiers you can
use the function described next.

@defun display-buffer-normalize-specifiers buffer-name specifiers label
This function returns the normalized specifiers for a buffer matching
@var{buffer-name} or @var{label}.  The argument @var{buffer-name} must
be a string specifying a valid buffer name.  The arguments
@var{specifiers} and @var{label} are the homonymous arguments of
@code{display-buffer}.
@end defun

In the four functions described next, the optional argument
@var{specifiers} must be a list of normalized buffer display specifiers
as returned by @code{display-buffer-normalize-specifiers}.  These
functions return the window displaying the @var{buffer} if they
succeeded, @code{nil} otherwise.

@defun display-buffer-reuse-window buffer method &optional specifiers
This function tries to display @var{buffer} in an existing window.  The
argument @var{method} must be a list in the form of the @sc{cdr} of a
@code{reuse-window} buffer display specifier.  The first element must
specifiy the window to use, and can be either @code{nil}, @code{same},
@code{other}, or a live window.  The second element specifies whether
the window's buffer must be the same as @var{buffer} or another one and
can be either @code{nil}, @code{same}, @code{other}.  It can be also a
live buffer which means to reuse a window only if @var{buffer} is the
buffer it displays.  The third element is the frame to use - either
@code{nil}, 0 (the number zero), @code{visible}, @code{t}, or a live
frame.
@end defun

@defun display-buffer-pop-up-window buffer methods &optional specifiers
This function tries to display @var{buffer} in a new window.  The
argument @var{methods} must be a list of window/side tuples like those
forming the @sc{cdr} of the @code{pop-up-window} buffer display
specifier.  As a special case, the @sc{car} of such a tuple can be also
a live window.
@end defun

@defun display-buffer-pop-up-frame buffer &optional graphic-only specifiers
This function tries to make a new frame for displaying @var{buffer}.
The optional argument @var{graphic-only} non-@code{nil} means to make a
new frame on graphic displays only.
@end defun

@defun display-buffer-in-side-window buffer side &optional slot specifiers
This function tries to display @var{buffer} in a window on @var{side} of
the selected frame (@pxref{Side Windows}).  The argument @var{slot}, if
non-@code{nil}, specifies the window slot where to display the
@var{buffer}.  If @var{slot} is zero or @code{nil}, this means use the
central slot on @var{side}.  A negative value means to use a slot
preceding the central window.  A positive value means to use a slot
following the central window.
@end defun

The following functions are simple interfaces to @code{display-buffer}.

@defun display-buffer-same-window &optional buffer-or-name label
This function is like @code{display-buffer} but preferably displays the
buffer specified by @var{buffer-or-name} in the selected window.
Another window will be used only if the buffer can't be shown in the
selected window, usually because it is dedicated to some other buffer.
@end defun

@defun display-buffer-same-frame &optional buffer-or-name label
This function is like @code{display-buffer} but tries to avoid using
another frame.
@end defun

@defun display-buffer-other-window &optional buffer-or-name label
This function is like @code{display-buffer} but tries to avoid using the
selected window.
@end defun

@defun display-buffer-other-window-same-frame &optional buffer-or-name label
This function is like @code{display-buffer-other-window} but tries to
avoid using another frame.
@end defun

The following variable conveys some information about the last
@code{display-buffer} action performed and is used mainly when popping
up a @samp{*Help*} buffer.

@defvar display-buffer-window
After @code{display-buffer} has shown a buffer in some window this
variable should be a cons cell whose @sc{car} denotes the window used to
display the buffer.  The @sc{cdr} is either @code{new-window} (which
means a new window has been made), @code{new-frame} (a new frame has
been created), @code{reuse-buffer-window} (a window showing the buffer
has been reused), @code{reuse-other-window} (some other window has been
reused).

If @code{display-buffer-function} is non-@code{nil}, the function called
here becomes responsible for assigning a meaningful value to this
variable.  Otherwise, the @code{display-buffer} code takes care of this.
@end defvar

The command described next allows to quit the window chosen by
@code{display-buffer} and restore the previous state without undoing
changes to the window configuration that happend @emph{after}
@code{display-buffer} was called.  A more drastic solution is to save
the window configuration before calling @code{display-buffer} and
eventually restoring the saved configuration, @ref{Window
Configurations}.  That solution sometimes has the undesirable
side-effect that all changes that happened after the configuration was
saved are undone too.

@deffn Command quit-restore-window &optional window kill
This command ``quits'' @var{window} restoring its previous contents if
possible.  The argument @var{window} must be a live window and defaults
to the selected one.  This function always returns @code{nil}.

According to information stored in @var{window}'s @code{quit-restore}
window parameter (@pxref{Window Parameters}) this function performs one
of the following actions.

@itemize @bullet

@item
Delete @var{window} and its frame.  This action is useful when
@var{window} was created on a standalone frame and there are other
frames left.

@item
Delete @var{window}.  This action is usually taken when @var{window} was
obtained by splitting some existing window.

@item
Restore the buffer previously displayed in @var{window}.  This action
is taken when @var{window} was temporarily reused for displaying some
other buffer.

@item
Make @var{window} display some other buffer.  This action is usually
taken when the three preceding ones are not applicable.
@end itemize

If the optional argument @var{kill} is non-@code{nil}, this means in
addition kill @var{window}'s buffer.  If @var{kill} is @code{nil}, this
simply puts @var{window}'s buffer at the end of the buffer list.
Interactively, @var{kill} is the prefix argument.
@end deffn


@node Switching Buffers
@section Switching to a Buffer in Some Window
@cindex switching to a buffer
@cindex popping to a buffer

In this section we describe convenient functions for switching to a
specified buffer in some window.  These functions can also split an
existing window or create a new frame in certain circumstances.  In any
case, the window chosen becomes the selected window and the buffer
current.

   Do not use the functions in this section in order to make a buffer
current so that a Lisp program can access or modify it; they are too
drastic for that purpose, since they change the display of buffers in
windows, which would be gratuitous and surprise the user.  Instead, use
@code{set-buffer} and @code{save-current-buffer} (@pxref{Current
Buffer}), which designate buffers as current for programmed access
without affecting the display of buffers in windows.

   The functions described here can be roughly divided into two groups
whose major representatives are the functions @code{switch-to-buffer}
and @code{pop-to-buffer} respectively.  Functions in the
@code{switch-to-buffer} group have the following distinguishing
characteristics:

@itemize @bullet
@item
They are reserved for interactive use; many of them have a predefined
keybinding.  Lisp code should @emph{never} call them.

@item
They can show a buffer in a window even if that window is dedicated to
another buffer.

@item
They do not have a @code{specifiers} or a @var{label} argument like
@code{display-buffer}.

@item
When the argument specifying the buffer that shall be displayed is
@code{nil}, they display the buffer returned by @code{other-buffer}.
@end itemize

Functions in the @code{pop-to-buffer} group have the following
characteristics.

@itemize @bullet
@item
They can be called interactively and from Lisp code.

@item
They respect the user customizations of @code{display-buffer-alist} and
@code{display-buffer-function}.  In particular, they try to not reuse a
dedicated window unless they are explicitly advised to do so.

@item
They can be passed a @code{specifiers} and a @var{label} argument, just
as @code{display-buffer}.

@item
When the argument specifying the buffer that shall be displayed is
@code{nil}, they try to display the current buffer.
@end itemize

For historical reasons, many Lisp function call @code{switch-to-buffer}.
These calls should be converted to @code{pop-to-buffer} calls.

@deffn Command switch-to-buffer buffer-or-name &optional norecord
This function makes the buffer specified by @var{buffer-or-name}
current, displays it in the selected window, and returns the buffer.
This means that a human can see the buffer and subsequent keyboard
commands will apply to it.  Contrast this with @code{set-buffer}, which
makes @var{buffer-or-name} the current buffer but does not display it in
the selected window; see @ref{Current Buffer}.

If @var{buffer-or-name} is @code{nil}, @code{switch-to-buffer} chooses a
buffer using @code{other-buffer}.  If @var{buffer-or-name} is a string
that does not identify an existing buffer, then a new buffer by that
name is created.  The major mode for the new buffer is set according to
the variable @code{major-mode}; see @ref{Auto Major Mode}.

If called interactively, it prompts for the buffer name using the
minibuffer.  The variable @code{confirm-nonexistent-file-or-buffer}
determines whether to request confirmation before creating a new buffer.

When the selected window is the minibuffer window or is strongly
dedicated to its buffer (@pxref{Dedicated Windows}), this function calls
@code{pop-to-buffer} (see below) to display the buffer in some other
window.

Normally, the specified buffer is put at the front of the buffer list
(both the selected frame's buffer list and the frame-independent buffer
list, see @ref{The Buffer List}).  This affects the operation of
@code{other-buffer}.  However, if @var{norecord} is non-@code{nil}, this
is not done.  Also, if @var{norecord} is non-@code{nil}, the window
chosen for displaying the buffer is not automatically made the most
recently selected one.

This function is intended for interactive use, as the binding of
@kbd{C-x b}.  Do @emph{not} call this function from Lisp code.  The
function @code{pop-to-buffer-same-window} should be used for that
purpose.
@end deffn

The next functions are similar to @code{switch-to-buffer}, except for
the described features.

@deffn Command switch-to-buffer-other-window buffer-or-name &optional norecord
This command makes the buffer specified by @var{buffer-or-name} current
and tries to display it in a window not currently selected, by using the
function @code{pop-to-buffer} (see below).  It returns the buffer
switched to.

This function tries hard to avoid using the selected window for doing
the job.  If the selected window already displays @var{buffer-or-name},
then it continues to do so, but another window is nonetheless found to
display it in as well.

The arguments @var{buffer-or-name} and @var{norecord} have the same
meaning as for @code{switch-to-buffer}.

This function is for interactive use, as the binding of @kbd{C-x 4 b}.
Do @emph{not} call this function from Lisp code.  The function
@code{pop-to-buffer-other-window} should be used for this purpose.
@end deffn

@deffn Command switch-to-buffer-same-frame buffer-or-name &optional norecord
This command is like @code{switch-to-buffer-other-window} but does not
necessarily avoid the selected window.  It does, however, try to use or
make a window on the selected frame.
@end deffn

@deffn Command switch-to-buffer-other-window-same-frame buffer-or-name &optional norecord
This command is like @code{switch-to-buffer-other-window} but tries to
use or make a window on the selected frame.
@end deffn

@deffn Command switch-to-buffer-other-frame buffer-or-name &optional norecord
This command is like @code{switch-to-buffer-other-window} but tries to
display the buffer on another frame.  This function has the binding
@kbd{C-x 4 b}.
@end deffn

The following functions take a @var{specifiers} and a @var{label}
argument and respect the same customizations as @code{display-buffer}.
Their only difference to the latter is that they @emph{always} select
the window chosen for displaying the buffer argument.

@deffn Command pop-to-buffer buffer-or-name &optional specifiers norecord label
This command makes @var{buffer-or-name} the current buffer and switches
to it in some window.  The ``popped-to'' window becomes the selected
window.  Its frame is given the X server's focus, if possible; see
@ref{Input Focus}.  The return value is the buffer that was switched to
or @code{nil} if no suitable window could be found.

   The optional argument @var{buffer-or-name} may be a buffer, a string
(a buffer name), or @code{nil}.  If @var{buffer-or-name} is a string not
naming an existent buffer, it creates a buffer with that name.  If
@var{buffer-or-name} is @code{nil} or omitted, it displays the current
buffer.

   The optional second argument @var{specifiers} must be a list of
buffer display specifiers or a single macro specifier, see the
documentations of @code{display-buffer} and @code{display-buffer-alist}.
If @var{specifiers} is @code{t}, it means to pop to the buffer in any
but the selected window.  If @var{specifiers} is @code{nil} or omitted,
this means to exclusively use the values provided by
@code{display-buffer-alist} (@pxref{Displaying Buffers}).  If these
values are nil too, default specifiers are used.

   The optional third argument @var{norecord} is handled just as by
@code{switch-to-buffer}.  The optional fourth argument @var{label}
specifies the buffer display label just as for @code{display-buffer}.
@end deffn

The following commands are similar to @code{pop-to-buffer} but for the
mentioned differences.

@deffn Command pop-to-buffer-same-window &optional buffer-or-name norecord label
This command is like @code{pop-to-buffer} but tries to display the
buffer in the selected window.  Another window will be used only if the
buffer can't be shown in the selected window, usually because the window
is dedicated to another buffer.
@end deffn

@deffn Command pop-to-buffer-same-frame &optional buffer-or-name norecord label
This command is like @code{pop-to-buffer} but tries to make or use a
window on the selected frame.
@end deffn

@deffn Command pop-to-buffer-other-window &optional buffer-or-name norecord label
This command is like @code{pop-to-buffer} but tries to avoid the
selected window.  Windows on the selected frame are preferred to windows
on other frames.
@end deffn

@deffn Command pop-to-buffer-other-window-same-frame &optional buffer-or-name norecord label
This command is like @code{pop-to-buffer-other-window} but tries to make
or use a window on the selected frame.
@end deffn

@deffn Command pop-to-buffer-other-frame &optional buffer-or-name norecord label
This command is like @code{pop-to-buffer} but preferably displays the
buffer on another frame.
@end deffn


@node Dedicated Windows
@section Dedicated Windows
@cindex dedicated window

Functions for displaying a buffer can be told to not use specific
windows by marking these windows as @dfn{dedicated} to their buffers.
The function @code{display-buffer} (@pxref{Displaying Buffers}) never
uses a dedicated window for displaying another buffer in it.  The
functions @code{get-lru-window} and @code{get-largest-window}
(@pxref{Selecting Windows}) do not consider dedicated windows as
candidates when their @var{dedicated} argument is non-@code{nil}.  The
behavior of @code{set-window-buffer} (@pxref{Buffers and Windows}) with
respect to dedicated windows is slightly different, see below.

When @code{delete-windows-on} (@pxref{Deleting Windows}) wants to delete
a dedicated window and that window is the only window on its frame, it
deletes the window's frame too, provided there are other frames left.
The function @code{replace-buffer-in-windows} (@pxref{Displaying
Buffers}) tries to delete all dedicated windows showing its buffer
argument.  When such a window is the only window on its frame, that
frame is deleted, provided there are other frames left.  If there are no
more frames left, some other buffer is displayed in the window, and the
window is marked as non-dedicated.

When you kill a buffer (@pxref{Killing Buffers}) displayed in a
dedicated window, any such window usually gets deleted too, since
@code{kill-buffer} calls @code{replace-buffer-in-windows} for cleaning
up windows.  Burying a buffer (@pxref{The Buffer List}) deletes the
selected window if it is dedicated to that buffer.  If, however, that
window is the only window on its frame, @code{bury-buffer} displays
another buffer in it and iconifies the frame.

@defun window-dedicated-p &optional window
This function returns non-@code{nil} if @var{window} is dedicated to its
buffer and @code{nil} otherwise.  More precisely, the return value is
the value assigned by the last call of @code{set-window-dedicated-p} for
@var{window} or @code{nil} if that function was never called with
@var{window} as its argument.  The default for @var{window} is the
selected window.
@end defun

@defun set-window-dedicated-p window flag
This function marks @var{window} as dedicated to its buffer if
@var{flag} is non-@code{nil}, and non-dedicated otherwise.

As a special case, if @var{flag} is @code{t}, @var{window} becomes
@dfn{strongly} dedicated to its buffer.  @code{set-window-buffer}
signals an error when the window it acts upon is strongly dedicated to
its buffer and does not already display the buffer it is asked to
display.  Other functions do not treat @code{t} differently from any
non-@code{nil} value.
@end defun


@node Window Point
@section Windows and Point
@cindex window position
@cindex window point
@cindex position in window
@cindex point in window

Each window has its own value of point (@pxref{Point}), independent of
the value of point in other windows displaying the same buffer.  This
makes it useful to have multiple windows showing one buffer.

@itemize @bullet
@item
The window point is established when a window is first created; it is
initialized from the buffer's point, or from the window point of another
window opened on the buffer if such a window exists.

@item
Selecting a window sets the value of point in its buffer from the
window's value of point.  Conversely, deselecting a window sets the
window's value of point from that of the buffer.  Thus, when you switch
between windows that display a given buffer, the point value for the
selected window is in effect in the buffer, while the point values for
the other windows are stored in those windows.

@item
As long as the selected window displays the current buffer, the window's
point and the buffer's point always move together; they remain equal.
@end itemize

@cindex cursor
   As far as the user is concerned, point is where the cursor is, and
when the user switches to another buffer, the cursor jumps to the
position of point in that buffer.

@defun window-point &optional window
This function returns the current position of point in @var{window}.
For a nonselected window, this is the value point would have (in that
window's buffer) if that window were selected.  The default for
@var{window} is the selected window.

When @var{window} is the selected window and its buffer is also the
current buffer, the value returned is the same as point in that buffer.
Strictly speaking, it would be more correct to return the ``top-level''
value of point, outside of any @code{save-excursion} forms.  But that
value is hard to find.
@end defun

@defun set-window-point window position
This function positions point in @var{window} at position
@var{position} in @var{window}'s buffer.  It returns @var{position}.

If @var{window} is selected, and its buffer is current,
this simply does @code{goto-char}.
@end defun

@defvar window-point-insertion-type
This variable specifies the marker insertion type (@pxref{Marker
Insertion Types}) of @code{window-point}.  The default is @code{nil},
so @code{window-point} will stay behind text inserted there.
@end defvar


@node Window Start and End
@section The Window Start and End Positions
@cindex window start position

  Each window maintains a marker used to keep track of a buffer position
that specifies where in the buffer display should start.  This position
is called the @dfn{display-start} position of the window (or just the
@dfn{start}).  The character after this position is the one that appears
at the upper left corner of the window.  It is usually, but not
inevitably, at the beginning of a text line.

  After switching windows or buffers, and in some other cases, if the
window start is in the middle of a line, Emacs adjusts the window
start to the start of a line.  This prevents certain operations from
leaving the window start at a meaningless point within a line.  This
feature may interfere with testing some Lisp code by executing it
using the commands of Lisp mode, because they trigger this
readjustment.  To test such code, put it into a command and bind the
command to a key.

@defun window-start &optional window
@cindex window top line
This function returns the display-start position of window
@var{window}.  If @var{window} is @code{nil}, the selected window is
used.  For example,

@example
@group
(window-start)
     @result{} 7058
@end group
@end example

When you create a window, or display a different buffer in it, the
display-start position is set to a display-start position recently used
for the same buffer, or to @code{point-min} if the buffer doesn't have
any.

Redisplay updates the window-start position (if you have not specified
it explicitly since the previous redisplay)---to make sure point appears
on the screen.  Nothing except redisplay automatically changes the
window-start position; if you move point, do not expect the window-start
position to change in response until after the next redisplay.

For a realistic example of using @code{window-start}, see the
description of @code{count-lines}.  @xref{Definition of count-lines}.
@end defun

@cindex window end position
@defun window-end &optional window update
This function returns the position where display of its buffer ends in
@var{window}.  The default for @var{window} is the selected window.

Simply changing the buffer text or moving point does not update the
value that @code{window-end} returns.  The value is updated only when
Emacs redisplays and redisplay completes without being preempted.

If the last redisplay of @var{window} was preempted, and did not finish,
Emacs does not know the position of the end of display in that window.
In that case, this function returns @code{nil}.

If @var{update} is non-@code{nil}, @code{window-end} always returns an
up-to-date value for where display ends, based on the current
@code{window-start} value.  If a previously saved value of that position
is still valid, @code{window-end} returns that value; otherwise it
computes the correct value by scanning the buffer text.

Even if @var{update} is non-@code{nil}, @code{window-end} does not
attempt to scroll the display if point has moved off the screen, the
way real redisplay would do.  It does not alter the
@code{window-start} value.  In effect, it reports where the displayed
text will end if scrolling is not required.
@end defun

@defun set-window-start window position &optional noforce
This function sets the display-start position of @var{window} to
@var{position} in @var{window}'s buffer.  It returns @var{position}.

The display routines insist that the position of point be visible when a
buffer is displayed.  Normally, they change the display-start position
(that is, scroll the window) whenever necessary to make point visible.
However, if you specify the start position with this function using
@code{nil} for @var{noforce}, it means you want display to start at
@var{position} even if that would put the location of point off the
screen.  If this does place point off screen, the display routines move
point to the left margin on the middle line in the window.

For example, if point @w{is 1} and you set the start of the window
@w{to 37}, the start of the next line, point will be ``above'' the top
of the window.  The display routines will automatically move point if
it is still 1 when redisplay occurs.  Here is an example:

@example
@group
;; @r{Here is what @samp{foo} looks like before executing}
;;   @r{the @code{set-window-start} expression.}
@end group

@group
---------- Buffer: foo ----------
@point{}This is the contents of buffer foo.
2
3
4
5
6
---------- Buffer: foo ----------
@end group

@group
(set-window-start
 (selected-window)
 (save-excursion
   (goto-char 1)
   (forward-line 1)
   (point)))
@result{} 37
@end group

@group
;; @r{Here is what @samp{foo} looks like after executing}
;;   @r{the @code{set-window-start} expression.}
---------- Buffer: foo ----------
2
3
@point{}4
5
6
---------- Buffer: foo ----------
@end group
@end example

If @var{noforce} is non-@code{nil}, and @var{position} would place point
off screen at the next redisplay, then redisplay computes a new window-start
position that works well with point, and thus @var{position} is not used.
@end defun

@defun pos-visible-in-window-p &optional position window partially
This function returns non-@code{nil} if @var{position} is within the
range of text currently visible on the screen in @var{window}.  It
returns @code{nil} if @var{position} is scrolled vertically out of view.
Locations that are partially obscured are not considered visible unless
@var{partially} is non-@code{nil}.  The argument @var{position} defaults
to the current position of point in @var{window}; @var{window}, to the
selected window.  If @var{position} is @code{t}, that means to check the
last visible position in @var{window}.

The @code{pos-visible-in-window-p} function considers only vertical
scrolling.  If @var{position} is out of view only because @var{window}
has been scrolled horizontally, @code{pos-visible-in-window-p} returns
non-@code{nil} anyway.  @xref{Horizontal Scrolling}.

If @var{position} is visible, @code{pos-visible-in-window-p} returns
@code{t} if @var{partially} is @code{nil}; if @var{partially} is
non-@code{nil}, and the character following @var{position} is fully
visible, it returns a list of the form @code{(@var{x} @var{y})}, where
@var{x} and @var{y} are the pixel coordinates relative to the top left
corner of the window; otherwise it returns an extended list of the form
@code{(@var{x} @var{y} @var{rtop} @var{rbot} @var{rowh} @var{vpos})},
where @var{rtop} and @var{rbot} specify the number of off-window pixels
at the top and bottom of the row at @var{position}, @var{rowh} specifies
the visible height of that row, and @var{vpos} specifies the vertical
position (zero-based row number) of that row.

Here is an example:

@example
@group
;; @r{If point is off the screen now, recenter it now.}
(or (pos-visible-in-window-p
     (point) (selected-window))
    (recenter 0))
@end group
@end example
@end defun

@defun window-line-height &optional line window
This function returns the height of text line @var{line} in
@var{window}.  If @var{line} is one of @code{header-line} or
@code{mode-line}, @code{window-line-height} returns information about
the corresponding line of the window.  Otherwise, @var{line} is a text
line number starting from 0.  A negative number counts from the end of
the window.  The default for @var{line} is the current line in
@var{window}; the default for @var{window} is the selected window.

If the display is not up to date, @code{window-line-height} returns
@code{nil}.  In that case, @code{pos-visible-in-window-p} may be used
to obtain related information.

If there is no line corresponding to the specified @var{line},
@code{window-line-height} returns @code{nil}.  Otherwise, it returns
a list @code{(@var{height} @var{vpos} @var{ypos} @var{offbot})},
where @var{height} is the height in pixels of the visible part of the
line, @var{vpos} and @var{ypos} are the vertical position in lines and
pixels of the line relative to the top of the first text line, and
@var{offbot} is the number of off-window pixels at the bottom of the
text line.  If there are off-window pixels at the top of the (first)
text line, @var{ypos} is negative.
@end defun


@node Textual Scrolling
@section Textual Scrolling
@cindex textual scrolling
@cindex scrolling textually

  @dfn{Textual scrolling} means moving the text up or down through a
window.  It works by changing the value of the window's display-start
location.  It may also change the value of @code{window-point} to keep
point on the screen.

  Textual scrolling was formerly called ``vertical scrolling,'' but we
changed its name to distinguish it from the new vertical fractional
scrolling feature (@pxref{Vertical Scrolling}).

  In the commands @code{scroll-up} and @code{scroll-down}, the directions
``up'' and ``down'' refer to the motion of the text in the buffer at which
you are looking through the window.  Imagine that the text is
written on a long roll of paper and that the scrolling commands move the
paper up and down.  Thus, if you are looking at text in the middle of a
buffer and repeatedly call @code{scroll-down}, you will eventually see
the beginning of the buffer.

  Some people have urged that the opposite convention be used: they
imagine that the window moves over text that remains in place.  Then
``down'' commands would take you to the end of the buffer.  This view is
more consistent with the actual relationship between windows and the
text in the buffer, but it is less like what the user sees.  The
position of a window on the terminal does not move, and short scrolling
commands clearly move the text up or down on the screen.  We have chosen
names that fit the user's point of view.

  The textual scrolling functions (aside from
@code{scroll-other-window}) have unpredictable results if the current
buffer is different from the buffer that is displayed in the selected
window.  @xref{Current Buffer}.

  If the window contains a row which is taller than the height of the
window (for example in the presence of a large image), the scroll
functions will adjust the window's vertical scroll position to scroll
the partially visible row.  To disable this feature, Lisp code may bind
the variable @code{auto-window-vscroll} to @code{nil} (@pxref{Vertical
Scrolling}).

@deffn Command scroll-up &optional count
This function scrolls the text in the selected window upward
@var{count} lines.  If @var{count} is negative, scrolling is actually
downward.

If @var{count} is @code{nil} (or omitted), then the length of scroll
is @code{next-screen-context-lines} lines less than the usable height of
the window (not counting its mode line).

@code{scroll-up} returns @code{nil}, unless it gets an error
because it can't scroll any further.
@end deffn

@deffn Command scroll-down &optional count
This function scrolls the text in the selected window downward
@var{count} lines.  If @var{count} is negative, scrolling is actually
upward.

If @var{count} is omitted or @code{nil}, then the length of the scroll
is @code{next-screen-context-lines} lines less than the usable height of
the window (not counting its mode line).

@code{scroll-down} returns @code{nil}, unless it gets an error because
it can't scroll any further.
@end deffn

@deffn Command scroll-other-window &optional count
This function scrolls the text in another window upward @var{count}
lines.  Negative values of @var{count}, or @code{nil}, are handled
as in @code{scroll-up}.

You can specify which buffer to scroll by setting the variable
@code{other-window-scroll-buffer} to a buffer.  If that buffer isn't
already displayed, @code{scroll-other-window} displays it in some
window.

When the selected window is the minibuffer, the next window is normally
the one at the top left corner.  You can specify a different window to
scroll, when the minibuffer is selected, by setting the variable
@code{minibuffer-scroll-window}.  This variable has no effect when any
other window is selected.  When it is non-@code{nil} and the
minibuffer is selected, it takes precedence over
@code{other-window-scroll-buffer}.  @xref{Definition of
minibuffer-scroll-window}.

When the minibuffer is active, it is the next window if the selected
window is the one at the bottom right corner.  In this case,
@code{scroll-other-window} attempts to scroll the minibuffer.  If the
minibuffer contains just one line, it has nowhere to scroll to, so the
line reappears after the echo area momentarily displays the message
@samp{Beginning of buffer}.
@end deffn

@c Emacs 19 feature
@defvar other-window-scroll-buffer
If this variable is non-@code{nil}, it tells @code{scroll-other-window}
which buffer's window to scroll.
@end defvar

@defopt scroll-margin
This option specifies the size of the scroll margin---a minimum number
of lines between point and the top or bottom of a window.  Whenever
point gets within this many lines of the top or bottom of the window,
redisplay scrolls the text automatically (if possible) to move point
out of the margin, closer to the center of the window.
@end defopt

@defopt scroll-conservatively
This variable controls how scrolling is done automatically when point
moves off the screen (or into the scroll margin).  If the value is a
positive integer @var{n}, then redisplay scrolls the text up to
@var{n} lines in either direction, if that will bring point back into
proper view.  This behavior is called @dfn{conservative scrolling}.
Otherwise, scrolling happens in the usual way, under the control of
other variables such as @code{scroll-up-aggressively} and
@code{scroll-down-aggressively}.

The default value is zero, which means that conservative scrolling
never happens.
@end defopt

@defopt scroll-down-aggressively
The value of this variable should be either @code{nil} or a fraction
@var{f} between 0 and 1.  If it is a fraction, that specifies where on
the screen to put point when scrolling down.  More precisely, when a
window scrolls down because point is above the window start, the new
start position is chosen to put point @var{f} part of the window
height from the top.  The larger @var{f}, the more aggressive the
scrolling.

A value of @code{nil} is equivalent to .5, since its effect is to center
point.  This variable automatically becomes buffer-local when set in any
fashion.
@end defopt

@defopt scroll-up-aggressively
Likewise, for scrolling up.  The value, @var{f}, specifies how far
point should be placed from the bottom of the window; thus, as with
@code{scroll-up-aggressively}, a larger value scrolls more aggressively.
@end defopt

@defopt scroll-step
This variable is an older variant of @code{scroll-conservatively}.  The
difference is that it if its value is @var{n}, that permits scrolling
only by precisely @var{n} lines, not a smaller number.  This feature
does not work with @code{scroll-margin}.  The default value is zero.
@end defopt

@defopt scroll-preserve-screen-position
If this option is @code{t}, scrolling which would move the current
point position out of the window chooses the new position of point
so that the vertical position of the cursor is unchanged, if possible.

If it is non-@code{nil} and not @code{t}, then the scrolling functions
always preserve the vertical position of point, if possible.
@end defopt

@defopt next-screen-context-lines
The value of this variable is the number of lines of continuity to
retain when scrolling by full screens.  For example, @code{scroll-up}
with an argument of @code{nil} scrolls so that this many lines at the
bottom of the window appear instead at the top.  The default value is
@code{2}.
@end defopt

@deffn Command recenter &optional count
@cindex centering point
This function scrolls the text in the selected window so that point is
displayed at a specified vertical position within the window.  It does
not ``move point'' with respect to the text.

If @var{count} is a nonnegative number, that puts the line containing
point @var{count} lines down from the top of the window.  If
@var{count} is a negative number, then it counts upward from the
bottom of the window, so that @minus{}1 stands for the last usable
line in the window.  If @var{count} is a non-@code{nil} list, then it
stands for the line in the middle of the window.

If @var{count} is @code{nil}, @code{recenter} puts the line containing
point in the middle of the window, then clears and redisplays the entire
selected frame.

When @code{recenter} is called interactively, @var{count} is the raw
prefix argument.  Thus, typing @kbd{C-u} as the prefix sets the
@var{count} to a non-@code{nil} list, while typing @kbd{C-u 4} sets
@var{count} to 4, which positions the current line four lines from the
top.

With an argument of zero, @code{recenter} positions the current line at
the top of the window.  This action is so handy that some people make a
separate key binding to do this.  For example,

@example
@group
(defun line-to-top-of-window ()
  "Scroll current line to top of window.
Replaces three keystroke sequence C-u 0 C-l."
  (interactive)
  (recenter 0))

(global-set-key [kp-multiply] 'line-to-top-of-window)
@end group
@end example
@end deffn


@node Vertical Scrolling
@section Vertical Fractional Scrolling
@cindex vertical fractional scrolling
@cindex vertical scroll position

   @dfn{Vertical fractional scrolling} means shifting text in a window
up or down by a specified multiple or fraction of a line.  Each window
has a @dfn{vertical scroll position}, which is a number, never less than
zero.  It specifies how far to raise the contents of the window.
Raising the window contents generally makes all or part of some lines
disappear off the top, and all or part of some other lines appear at the
bottom.  The usual value is zero.

   The vertical scroll position is measured in units of the normal line
height, which is the height of the default font.  Thus, if the value is
.5, that means the window contents are scrolled up half the normal line
height.  If it is 3.3, that means the window contents are scrolled up
somewhat over three times the normal line height.

   What fraction of a line the vertical scrolling covers, or how many
lines, depends on what the lines contain.  A value of .5 could scroll a
line whose height is very short off the screen, while a value of 3.3
could scroll just part of the way through a tall line or an image.

@defun window-vscroll &optional window pixels-p
This function returns the current vertical scroll position of
@var{window}.  The default for @var{window} is the selected window.
If @var{pixels-p} is non-@code{nil}, the return value is measured in
pixels, rather than in units of the normal line height.

@example
@group
(window-vscroll)
     @result{} 0
@end group
@end example
@end defun

@defun set-window-vscroll window lines &optional pixels-p
This function sets @var{window}'s vertical scroll position to
@var{lines}.  If @var{window} is @code{nil}, the selected window is
used.  The argument @var{lines} should be zero or positive; if not, it
is taken as zero.


The actual vertical scroll position must always correspond
to an integral number of pixels, so the value you specify
is rounded accordingly.

The return value is the result of this rounding.

@example
@group
(set-window-vscroll (selected-window) 1.2)
     @result{} 1.13
@end group
@end example

If @var{pixels-p} is non-@code{nil}, @var{lines} specifies a number of
pixels.  In this case, the return value is @var{lines}.
@end defun

@defvar auto-window-vscroll
If this variable is non-@code{nil}, the line-move, scroll-up, and
scroll-down functions will automatically modify the vertical scroll
position to scroll through display rows that are taller than the height
of the window, for example in the presence of large images.
@end defvar


@node Horizontal Scrolling
@section Horizontal Scrolling
@cindex horizontal scrolling

  @dfn{Horizontal scrolling} means shifting the image in the window left
or right by a specified multiple of the normal character width.  Each
window has a @dfn{horizontal scroll position}, which is a number, never
less than zero.  It specifies how far to shift the contents left.
Shifting the window contents left generally makes all or part of some
characters disappear off the left, and all or part of some other
characters appear at the right.  The usual value is zero.

  The horizontal scroll position is measured in units of the normal
character width, which is the width of space in the default font.  Thus,
if the value is 5, that means the window contents are scrolled left by 5
times the normal character width.  How many characters actually
disappear off to the left depends on their width, and could vary from
line to line.

  Because we read from side to side in the ``inner loop,'' and from top
to bottom in the ``outer loop,'' the effect of horizontal scrolling is
not like that of textual or vertical scrolling.  Textual scrolling
involves selection of a portion of text to display, and vertical
scrolling moves the window contents contiguously; but horizontal
scrolling causes part of @emph{each line} to go off screen.

  Usually, no horizontal scrolling is in effect; then the leftmost
column is at the left edge of the window.  In this state, scrolling to
the right is meaningless, since there is no data to the left of the edge
to be revealed by it; so this is not allowed.  Scrolling to the left is
allowed; it scrolls the first columns of text off the edge of the window
and can reveal additional columns on the right that were truncated
before.  Once a window has a nonzero amount of leftward horizontal
scrolling, you can scroll it back to the right, but only so far as to
reduce the net horizontal scroll to zero.  There is no limit to how far
left you can scroll, but eventually all the text will disappear off the
left edge.

@vindex auto-hscroll-mode
  If @code{auto-hscroll-mode} is set, redisplay automatically alters
the horizontal scrolling of a window as necessary to ensure that point
is always visible.  However, you can still set the horizontal
scrolling value explicitly.  The value you specify serves as a lower
bound for automatic scrolling, i.e. automatic scrolling will not
scroll a window to a column less than the specified one.

@deffn Command scroll-left &optional count set-minimum
This function scrolls the selected window @var{count} columns to the
left (or to the right if @var{count} is negative).  The default
for @var{count} is the window width, minus 2.

The return value is the total amount of leftward horizontal scrolling in
effect after the change---just like the value returned by
@code{window-hscroll} (below).

Once you scroll a window as far right as it can go, back to its normal
position where the total leftward scrolling is zero, attempts to scroll
any farther right have no effect.

If @var{set-minimum} is non-@code{nil}, the new scroll amount becomes
the lower bound for automatic scrolling; that is, automatic scrolling
will not scroll a window to a column less than the value returned by
this function.  Interactive calls pass non-@code{nil} for
@var{set-minimum}.
@end deffn

@deffn Command scroll-right &optional count set-minimum
This function scrolls the selected window @var{count} columns to the
right (or to the left if @var{count} is negative).  The default
for @var{count} is the window width, minus 2.  Aside from the direction
of scrolling, this works just like @code{scroll-left}.
@end deffn

@defun window-hscroll &optional window
This function returns the total leftward horizontal scrolling of
@var{window}---the number of columns by which the text in @var{window}
is scrolled left past the left margin.  The default for
@var{window} is the selected window.

The return value is never negative.  It is zero when no horizontal
scrolling has been done in @var{window} (which is usually the case).


@example
@group
(window-hscroll)
     @result{} 0
@end group
@group
(scroll-left 5)
     @result{} 5
@end group
@group
(window-hscroll)
     @result{} 5
@end group
@end example
@end defun

@defun set-window-hscroll window columns
This function sets horizontal scrolling of @var{window}.  The value of
@var{columns} specifies the amount of scrolling, in terms of columns
from the left margin.  The argument @var{columns} should be zero or
positive; if not, it is taken as zero.  Fractional values of
@var{columns} are not supported at present.

Note that @code{set-window-hscroll} may appear not to work if you test
it by evaluating a call with @kbd{M-:} in a simple way.  What happens
is that the function sets the horizontal scroll value and returns, but
then redisplay adjusts the horizontal scrolling to make point visible,
and this overrides what the function did.  You can observe the
function's effect if you call it while point is sufficiently far from
the left margin that it will remain visible.

The value returned is @var{columns}.

@example
@group
(set-window-hscroll (selected-window) 10)
     @result{} 10
@end group
@end example
@end defun

   Here is how you can determine whether a given position @var{position}
is off the screen due to horizontal scrolling:

@example
@group
(defun hscroll-on-screen (window position)
  (save-excursion
    (goto-char position)
    (and
     (>= (- (current-column) (window-hscroll window)) 0)
     (< (- (current-column) (window-hscroll window))
        (window-width window)))))
@end group
@end example


@node Coordinates and Windows
@section Coordinates and Windows

This section describes how to relate edges and screen coordinates to
windows.

@defun window-edges &optional window
This function returns a list of the edge coordinates of @var{window}.
The default for @var{window} is the selected window.

The order of the list is @code{(@var{left} @var{top} @var{right}
@var{bottom})}, all elements relative to 0, 0 at the top left corner of
the frame.  The element @var{right} of the value is one more than the
rightmost column used by @var{window}, and @var{bottom} is one more than
the bottommost row used by @var{window} and its mode-line.

The edges include the space used by the window's scroll bar, display
margins, fringes, header line, and mode line, if it has them.  Also,
if the window has a neighbor on the right, its right edge value
includes the width of the separator line between the window and that
neighbor.  Since the width of the window does not include this
separator, the width does not usually equal the difference between the
right and left edges.
@end defun

@defun window-inside-edges &optional window
This is similar to @code{window-edges}, but the edge values
it returns include only the text area of the window.  They
do not include the header line, mode line, scroll bar or
vertical separator, fringes, or display margins.
@end defun

Here are the results obtained on a typical 24-line terminal with just
one window, with menu bar enabled:

@example
@group
(window-edges (selected-window))
     @result{} (0 1 80 23)
@end group
@group
(window-inside-edges (selected-window))
     @result{} (0 1 80 22)
@end group
@end example

@noindent
The bottom edge is at line 23 because the last line is the echo area.
The bottom inside edge is at line 22, which is the window's mode line.

If @var{window} is at the upper left corner of its frame, and there is
no menu bar, then @var{bottom} returned by @code{window-edges} is the
same as the value of @code{(window-total-height)}, @var{right} is the
same as the value of @code{(window-total-width)}, and @var{top} and
@var{left} are zero.  For example, the edges of the following window are
@w{@samp{0 0 8 5}}.  Assuming that the frame has more than 8 columns,
the last column of the window (column 7) holds a border rather than
text.  The last row (row 4) holds the mode line, shown here with
@samp{xxxxxxxxx}.

@example
@group
           0
           _______
        0 |       |
          |       |
          |       |
          |       |
          xxxxxxxxx  4

                  7
@end group
@end example

In the following example, let's suppose that the frame is 7
columns wide.  Then the edges of the left window are @w{@samp{0 0 4 3}}
and the edges of the right window are @w{@samp{4 0 7 3}}.
The inside edges of the left window are @w{@samp{0 0 3 2}},
and the inside edges of the right window are @w{@samp{4 0 7 2}},

@example
@group
           ___ ___
          |   |   |
          |   |   |
          xxxxxxxxx

           0  34  7
@end group
@end example

@defun window-pixel-edges &optional window
This function is like @code{window-edges} except that, on a graphical
display, the edge values are measured in pixels instead of in
character lines and columns.
@end defun

@defun window-inside-pixel-edges &optional window
This function is like @code{window-inside-edges} except that, on a
graphical display, the edge values are measured in pixels instead of
in character lines and columns.
@end defun

@defun window-at x y &optional frame
This function returns the window containing the specified cursor
position in the frame @var{frame}.  The coordinates @var{x} and @var{y}
are measured in characters and count from the top left corner of the
frame.  If they are out of range, @code{window-at} returns @code{nil}.

If you omit @var{frame}, the selected frame is used.
@end defun

@defun coordinates-in-window-p coordinates window
This function checks whether a particular frame position falls within
the window @var{window}.

The argument @var{coordinates} is a cons cell of the form @code{(@var{x}
. @var{y})}.  The coordinates @var{x} and @var{y} are measured in
characters, and count from the top left corner of the screen or frame.

The value returned by @code{coordinates-in-window-p} is non-@code{nil}
if the coordinates are inside @var{window}.  The value also indicates
what part of the window the position is in, as follows:

@table @code
@item (@var{relx} . @var{rely})
The coordinates are inside @var{window}.  The numbers @var{relx} and
@var{rely} are the equivalent window-relative coordinates for the
specified position, counting from 0 at the top left corner of the
window.

@item mode-line
The coordinates are in the mode line of @var{window}.

@item header-line
The coordinates are in the header line of @var{window}.

@item vertical-line
The coordinates are in the vertical line between @var{window} and its
neighbor to the right.  This value occurs only if the window doesn't
have a scroll bar; positions in a scroll bar are considered outside the
window for these purposes.

@item left-fringe
@itemx right-fringe
The coordinates are in the left or right fringe of the window.

@item left-margin
@itemx right-margin
The coordinates are in the left or right margin of the window.

@item nil
The coordinates are not in any part of @var{window}.
@end table

The function @code{coordinates-in-window-p} does not require a frame as
argument because it always uses the frame that @var{window} is on.
@end defun


@node Window Configurations
@section Window Configurations
@cindex window configurations
@cindex saving window information

  A @dfn{window configuration} records the entire layout of one
frame---all windows, their sizes, which buffers they contain, how those
buffers are scrolled, and their values of point and the mark; also their
fringes, margins, and scroll bar settings.  It also includes the value
of @code{minibuffer-scroll-window}.  As a special exception, the window
configuration does not record the value of point in the selected window
for the current buffer.

  You can bring back an entire frame layout by restoring a previously
saved window configuration.  If you want to record the layout of all
frames instead of just one, use a frame configuration instead of a
window configuration; see @ref{Frame Configurations}.

@defun current-window-configuration &optional frame
This function returns a new object representing @var{frame}'s current
window configuration.  The default for @var{frame} is the selected
frame.
@end defun

@defun set-window-configuration configuration
This function restores the configuration of windows and buffers as
specified by @var{configuration}, for the frame that @var{configuration}
was created for.

The argument @var{configuration} must be a value that was previously
returned by @code{current-window-configuration}.  The configuration is
restored in the frame from which @var{configuration} was made, whether
that frame is selected or not.  This always counts as a window size
change and triggers execution of the @code{window-size-change-functions}
(@pxref{Window Hooks}), because @code{set-window-configuration} doesn't
know how to tell whether the new configuration actually differs from the
old one.

If the frame which @var{configuration} was saved from is dead, all this
function does is restore the three variables @code{window-min-height},
@code{window-min-width} and @code{minibuffer-scroll-window}. In this
case, the function returns @code{nil}.  Otherwise, it returns @code{t}.

Here is a way of using this function to get the same effect
as @code{save-window-excursion}:

@example
@group
(let ((config (current-window-configuration)))
  (unwind-protect
      (progn (split-window-vertically nil)
             @dots{})
    (set-window-configuration config)))
@end group
@end example
@end defun

@defspec save-window-excursion forms@dots{}
This special form records the window configuration, executes @var{forms}
in sequence, then restores the earlier window configuration.  The window
configuration includes, for each window, the value of point and the
portion of the buffer that is visible.  It also includes the choice of
selected window.  However, it does not include the value of point in
the current buffer; use @code{save-excursion} also, if you wish to
preserve that.

Don't use this construct when @code{save-selected-window} is sufficient.

Exit from @code{save-window-excursion} always triggers execution of
@code{window-size-change-functions}.  (It doesn't know how to tell
whether the restored configuration actually differs from the one in
effect at the end of the @var{forms}.)

The return value is the value of the final form in @var{forms}.
For example:

@example
@group
(split-window)
     @result{} #<window 25 on control.texi>
@end group
@group
(setq w (selected-window))
     @result{} #<window 19 on control.texi>
@end group
@group
(save-window-excursion
  (delete-other-windows w)
  (switch-to-buffer "foo")
  'do-something)
     @result{} do-something
     ;; @r{The screen is now split again.}
@end group
@end example
@end defspec

@defun window-configuration-p object
This function returns @code{t} if @var{object} is a window configuration.
@end defun

@defun compare-window-configurations config1 config2
This function compares two window configurations as regards the
structure of windows, but ignores the values of point and mark and the
saved scrolling positions---it can return @code{t} even if those
aspects differ.

The function @code{equal} can also compare two window configurations; it
regards configurations as unequal if they differ in any respect, even a
saved point or mark.
@end defun

@defun window-configuration-frame config
This function returns the frame for which the window configuration
@var{config} was made.
@end defun

  Other primitives to look inside of window configurations would make
sense, but are not implemented because we did not need them.  See the
file @file{winner.el} for some more operations on windows
configurations.

  The objects returned by @code{current-window-configuration} die
together with the Emacs process.  In order to store a window
configuration on disk and read it back in another Emacs session the
following two functions can be used.

@defun window-state-get &optional window markers
This function returns the state of @var{window} as a Lisp object.  The
argument @var{window} can be any window and defaults to the root window
of the selected frame.

The optional argument @var{markers} non-@code{nil} means to use markers
for sampling positions like @code{window-point} or @code{window-start}.
This argument should be non-@code{nil} only if the value is used for
putting the state back in the same session since markers slow down
processing.

The return value can be used as argument for @code{window-state-put},
see below, to put the state recorded here into an arbitrary window.  The
value can be also stored on disk and read back in a new session.
@end defun

The value returned by @code{window-state-get} can be converted by using
one of the functions defined by Desktop Save Mode (@pxref{Desktop Save
Mode}) to an object that can be written to a file.  Such objects can be
read back and converted to a Lisp object representing the state of the
window.  That Lisp object can be used as argument for the following
function in order to restore the state window in anothe window.

@defun window-state-put state &optional window ignore
This function puts the window state @var{state} into @var{window}.  The
argument @var{state} should be the state of a window returned by an
earlier invocation of @code{window-state-get}, see above.  The optional
argument @var{window} must specify a live window and defaults to the
selected one.

The optional argument @var{ignore} non-@code{nil} means to ignore
minimum window sizes and fixed size restrictions.  If @var{ignore}
equals @code{safe}, this means subwindows can get as small as
@code{window-safe-min-height} and @code{window-safe-min-width}.
@end defun


@node Window Parameters
@section Window Parameters
@cindex window parameters

This section describes how window parameters can be used to associate
additional information with windows.

@defun window-parameter window parameter
This function returns @var{window}'s value for @var{parameter}.  The
default for @var{window} is the selected window.  If @var{window} has no
setting for @var{parameter}, this function returns @code{nil}.
@end defun

@defun window-parameters &optional window
This function returns all parameters of @var{window} and their values.
The default for @var{window} is the selected window.  The return value,
if non-@code{nil} is an association list whose elements have the form
@code{(@var{parameter} . @var{value})}.
@end defun

@defun set-window-parameter window parameter value
This function sets @var{window}'s value of @var{parameter} to
@var{value} and returns @var{value}.  The default for @var{window}
is the selected window.
@end defun

   A list of windows whose parameter equals some value is produced by
the following function.

@defun windows-with-parameter parameter &optional value frame any values
This function returns a list of all windows on @var{frame} whose
@var{parameter} is non-@code{nil}.  The optional argument @var{frame}
must denote a live frame and defaults to the selected one.

If the optional argument @var{value} is non-@code{nil}, this means to
only return windows whose @var{parameter} equals @var{value} (comparison
is done using @code{equal}).  Optional argument @var{any} non-@code{nil}
means list internal windows a well.  Optional argument @var{values}
non-@code{nil} means return a list of cons cells whose @sc{car} is the
value of the parameter and whose @sc{cdr} is the window.
@end defun

   The first window with a specified parameter can be retrieved with the
following function.

@defun window-with-parameter parameter &optional value frame any
This function returns the first window on @var{frame} whose
@var{parameter} is non-@code{nil}.  The optional argument @var{frame}
must denote a live frame and defaults to the selected one.

If the optional argument @var{value} is non-@code{nil}, this means to
only return a window whose @var{parameter} equals @var{value}
(comparison is done with @code{equal}).  If the optional argument
@var{any} is non-@code{nil}, this means to consider internal windows
too.
@end defun

Some functions, notably @code{split-window}, @code{delete-window}, and
@code{delete-other-windows} behave specially when their @var{window}
argument has a parameter set.  For example, @code{delete-window} when
invoked on the main window of an atomic window (@pxref{Atomic Windows})
calls @code{delete-window} with the root window of the atomic window as
argument instead.  The entire information for retrieving the appropriate
root window is maintained with the help of window parameters.

You can override that special behavior by binding the following variable
to a non-@code{nil} value:

@defvar ignore-window-parameters
If this variable is non-@code{nil}, some standard functions ignore
window parameters.  The functions currently affected by this are
@code{split-window}, @code{delete-window}, @code{delete-other-windows}
and @code{other-window}.

An application can bind this variable to a non-@code{nil} value around
calls to these functions.  If it does so, the application is fully
responsible for correctly assigning the parameters of windows when
exiting that function.
@end defvar

The following parameters are currently used by the window management
code.

@table @asis
@item @code{window-atom}
This symbol designates the associated window as part of an atomic
window (@pxref{Atomic Windows}).

@item @code{window-side}
This symbol designates the associated window as part of a side or
non-side window (@pxref{Side Windows}).

@item @code{delete-window-function}
This parameter is used by @code{delete-window} (@pxref{Deleting
Windows}).

@item @code{delete-other-windows-function}
This parameter is used by @code{delete-other-windows} (@pxref{Deleting
Windows}).

@item @code{split-window-function}
This parameter is used by @code{split-window} (@pxref{Splitting
Windows}).

@item @code{other-window-function}
This parameter is used by @code{other-window} (@pxref{Cyclic Window
Ordering}).

@item @code{no-other-window}
This parameter marks the window as not selectable by @code{other-window}
(@pxref{Cyclic Window Ordering}).
@end table

The @code{quit-restore} parameter tells how to proceed with a window
when the user ``quits'' it by invoking @code{quit-restore-window}, see
@ref{Displaying Buffers}.  The following non-@code{nil} values of this
parameter have a special meaning.

@table @asis
@item @code{t}
This means to delete the associated window.  By default, @code{t} is
used for a ``temporary'' window that was obtained by splitting an
existing window.

@item @code{frame}
This means to delete the associated window's frame.  This value
indicates that the associated windows was obtained by popping up a new
frame showing just this window.  If the window is no more needed, it
should be deleted together with the containing frame.

@item A list
This option is useful when the associated window was borrowed to
temporarily display some buffer and quitting shall ``restore'' the
previous contents of the window.  The first three elements of the list
must specify a buffer, a window start position, and a window point.
Quitting the window will then try to display the indicated buffer with
the given start position and point in that window.

  The fourth element, if non-@code{nil}, must denote a live buffer.  If
specified, quitting will restore the previous window contents if and
only if the buffer shown in the window is the buffer named by this
element.

  The fifth element, if non-@code{nil}, should specify the desired
height of the window when its buffer is restored.  This value is applied
if the buffer temporarily shown in the window was in
@code{temp-buffer-resize-mode} to restore the original height of the
window.
@end table


@node Atomic Windows
@section Atomic Windows
@cindex atomic windows

An @dfn{atomic window} is an internal window (@pxref{Basic Windows})
built from two or more subwindows.  For any subwindow of an atomic
window the behavior of a number of operations changes in the sense that
the operation is suitably applied to the entire atomic window instead.

   Atomic windows are useful when you're using two side-by-side windows
to compare or merge buffers.  In this case, you probably don't want
commands like @code{display-buffer} or @kbd{C-x 2} break your window
layout by splitting one of these windows.  Making these windows part of
an atomic window guarantees that the entire atomic window is split
instead.

   Another use of atomic windows is that of a sidebar, toolbar or tabbar
appearing on the left or above a ``main'' window.  In this case,
splitting the main window should not break the correspondence between
the bar and the main window.  With atomic windows the relationship
between the bar and the main window remains untouched.

   Atomic windows can be created by calling @code{display-buffer}
(@pxref{Displaying Buffers}) with a non-@code{nil} @code{pop-up-window}
and @code{atomic} specifier.  The following call displays a buffer named
``*bar*'' in a 10 columns wide window on the left of the selected
window.

@example
(display-buffer
 (get-buffer-create "*bar*")
 '((pop-up-window (selected . left))
   (pop-up-window-set-width . 10)
   (atomic . t)))
@end example

Alternatively, applications can use @code{display-buffer-pop-up-window}
(@pxref{Displaying Buffers}) in order to make sure that the buffer is
not displayed in some other window provided the selected window can't be
split.

@example
(display-buffer-pop-up-window
 (get-buffer-create "*bar*")
 '((selected . left))
 '((pop-up-window-set-width . 10) (atomic . nest)))
@end example

To make an internal window atomic use the following function:

@defun make-window-atom window
This function make @var{window} an atomic window.  The argument
@var{window} must be an internal window.  It returns @var{window}.
@end defun

   Atomic windows are implemented by setting their @code{window-atom}
parameter (@pxref{Window Parameters}) and that of their subwindows to
@code{t}.  To check whether a given window is or is part of an atomic
window simply look at that parameter.  If

@smallexample
(window-parameter window 'window-atom)
@end smallexample

returns @code{t}, the window is part of an atomic window.  To find the
atomic window a given window is part of, use the following function:

@defun window-atom-root window
This function returns the atomic window @var{window} belongs to;
@code{nil} if @var{window} is not part of an atomic window.
@end defun

   By default, the behavior of the following commands changes when their
window argument is a member of an atomic window and the variable
@code{ignore-window-parameters} is non-@code{nil}.

@table @asis
@item @code{split-window} (@pxref{Splitting Windows})
When @var{window} is part of an atomic window, @code{split-window} tries
to split the atomic window instead.

@item @code{delete-window} (@pxref{Deleting Windows})
When @var{window} is part of an atomic window, @code{delete-window}
deletes the atomic window instead.  If that window is the root window of
its containing frame, an error is signalled.

@item @code{delete-other-windows} (@pxref{Deleting Windows})
When @var{window} is part of an atomic window,
@code{delete-other-windows} makes the atomic window fill its frame.  If
the atomic window is a non-side window (@pxref{Side Windows}), all other
non-side windows are removed.  If the atomic window is a side window, an
error is signalled.
@end table

You can override the default behavior of these commands by using an
appropriate @code{split-window-function}, @code{delete-window-function}
or @code{delete-other-windows-function}.

The following two invariants must be maintained by all operations on
atomic windows:

@itemize @bullet
@item
An atomic window must contain at least two subwindows.

@item
The @code{window-atom} parameter of an atomic window and of any of its
subwindows must be @code{t}.
@end itemize

Atomic windows violating these invariants are automatically dissolved.
Their component windows continue to exist as normal windows.  Operating
on them, however, is no more different from operating on any other
window.


@node Side Windows
@section Side Windows
@cindex side windows
@cindex non-side windows

A @dfn{side window} is a special window located at one of the four sides
of a frame.  Side windows are useful for assigning buffers always the
same location within a frame whenever they are shown there.  Typically,
side windows would be used for viewing compiler or grep output, buffer
or file listings, completions, or system messages.  They would be
arranged around a set of ``non-side'' windows used for buffers that are
edited.

   The following option specifies the layout of side windows on a frame.

@defopt window-sides-vertical
If non-@code{nil}, this variable specifies that left and right side
windows are as high as the containing frame.  Otherwise, top and bottom
side windows are as wide as the containing frame.

Changing this option while side-windows are displayed may lead to
unexpected layouts and should be avoided.
@end defopt

If @code{window-sides-vertical} is @code{nil}, side windows appear as
follows:

@smallexample
@group
         ______________________________________ 
        |                                      |
        |              Top Window              |
        |______________________________________|
        |        |                    |        |
        | Left   |                    | Right  |
        | Side   |   Non-side Window  | Side   |
        | Window |                    | Window |
        |________|____________________|________|
        |                                      |
        |             Bottom Window            |
        |______________________________________|

@end group
@end smallexample

If @code{window-sides-vertical} is non-@code{nil}, side windows are
displayed as follows:

@smallexample
@group
         ______________________________________ 
        |        |                    |        |
        |        |     Top Window     |        |
        |        |____________________|        |
        |        |                    |        |
        | Left   |                    | Right  |
        | Side   |   Non-side Window  | Side   |
        | Window |                    | Window |
        |        |____________________|        |
        |        |                    |        |
        |        |    Bottom Window   |        |
        |________|____________________|________|

@end group
@end smallexample

   Side windows can be arbitrarily subdivided.  For each side of a frame
there exists at most one dominating side window which contains all other
windows on the same side as subwindows.  As a rule, windows on the left
or right side of a frame should be vertical combinations.  Windows on
the top or bottom of a frame should be horizontal combinations.  This
makes it easier to assign each life side window a corresponding slot.

@cindex side window slot
A @dfn{side window slot} indicates the relative position of a side
window within the dominating window on that side.  Slots are arbitrary
numbers where the value zero roughly stands for a window in the middle
of that side.  Negative numbers indicate a position above the middle
window (for left and right side windows) or on the left (for the top and
bottom side windows).  Positive numbers stand for windows below the
middle window (for left and right side windows) or on the right (for top
and bottom side windows).

The example below depicts a layout with three subwindows on the top and
two subwindows at the bottom of the frame.

@smallexample
@group
         ______________________________________ 
        | Left Top   | Middle Top |  Right Top |
        | Window     | Window     |  Window    |
        |____________|____________|____________|
        |        |                    |        |
        | Left   |                    | Right  |
        | Side   |   Non-side Window  | Side   |
        | Window |                    | Window |
        |________|____________________|________|
        | Left Bottom      |      Right Bottom |
        | Window           |      Window       |
        |__________________|___________________|

@end group
@end smallexample

The following option can be used to limit the number of subwindows that
may appear on any side of a frame.

@defopt window-sides-slots
This is a list of four elements specifying the number of side window
slots on (in this order) the left, top, right and bottom side of each
frame.  If an element is a number, this means to display at most that
many side windows on the corresponding side.  If an element is
@code{nil}, this means there's no bound on the number of slots on that
side.
@end defopt

   Side windows are implemented with the help of @code{window-side}
parameters (@pxref{Window Parameters}).  This parameter is @code{left},
@code{top}, @code{right} or @code{bottom} for a window on the
corresponding side and @code{none} for a non-side window.  The
dominating window on each side as well as the dominating non-side window
have parents whose @code{window-side} parameter is nil.  To get the
dominating side window on the left, for example, use the function
@code{window-with-parameter} like

@smallexample
(window-with-parameter 'window-side 'left nil t)
@end smallexample

   If you create side windows by calling @code{display-buffer}
(@pxref{Displaying Buffers}) with the @code{use-side-window} specifier,
this will set up these parameters automatically.  If you want to manage
side windows manually, you should preserve the following invariants:

@itemize @bullet
@item
If a frame has a side window, a non-side window must exist on that frame
as well.  If a frame has a non-side window, at least one side window
must exist on that frame too.

@item
If a window has a non-@code{nil} @code{window-side} parameter, it must
have a parent window and the parent window's @code{window-side}
parameter must be either @code{nil} or the same as for the window.

@item
For any of the values @code{left}, @code{top}, @code{right},
@code{bottom} and @code{none} there can be only one dominating window
whose @code{window-side} parameter equals that value.  More precisely,
this means that at most one window can have its @code{window-side}
parameter set to such a value and have a parent window whose
@code{window-side} parameter is @code{nil}.

@item
Live windows whose @code{window-side} parameter is @code{nil} are
invalid.
@end itemize

If a setup of @code{window-side} parameters fails to satisfy these
invariants, Emacs will reset all @code{window-side} parameters on that
frame to @code{nil}.  Otherwise, the window configuration remains
unchanged.

The behavior of the following commands and functions changes in the
presence of side windows.

@table @asis
@item @code{split-window} (@pxref{Splitting Windows})
If the function @code{split-window} splits a window with a
non-@code{nil} @code{window-side} parameter it assigns the new window
the same parameter value.

@item @code{delete-window} (@pxref{Deleting Windows})
The function @code{delete-window} signal an error when it is invoked
with a non-side window as argument and there are side windows on the
associated frame.

@item @code{delete-other-windows} (@pxref{Deleting Windows})
When @code{delete-other-windows} is invoked with a non-side window as
argument, it will delete all other non-side windows (for an internal
window all non-side windows that are not a subwindow of this window),
When @code{delete-other-windows} is called with a side window as
argument it signals an error.
@end table


@node Window Hooks
@section Hooks for Window Scrolling and Changes
@cindex hooks for window operations

This section describes how a Lisp program can take action whenever a
window displays a different part of its buffer or a different buffer.
There are three actions that can change this: scrolling the window,
switching buffers in the window, and changing the size of the window.
The first two actions run @code{window-scroll-functions}; the last runs
@code{window-size-change-functions}.

@defvar window-scroll-functions
This variable holds a list of functions that Emacs should call before
redisplaying a window with scrolling.  Displaying a different buffer in
the window also runs these functions.

This variable is not a normal hook, because each function is called with
two arguments: the window, and its new display-start position.

These functions must be careful in using @code{window-end}
(@pxref{Window Start and End}); if you need an up-to-date value, you
must use the @var{update} argument to ensure you get it.

@strong{Warning:} don't use this feature to alter the way the window
is scrolled.  It's not designed for that, and such use probably won't
work.
@end defvar

@defvar window-size-change-functions
This variable holds a list of functions to be called if the size of any
window changes for any reason.  The functions are called just once per
redisplay, and just once for each frame on which size changes have
occurred.

Each function receives the frame as its sole argument.  There is no
direct way to find out which windows on that frame have changed size, or
precisely how.  However, if a size-change function records, at each
call, the existing windows and their sizes, it can also compare the
present sizes and the previous sizes.

Creating or deleting windows counts as a size change, and therefore
causes these functions to be called.  Changing the frame size also
counts, because it changes the sizes of the existing windows.

It is not a good idea to use @code{save-window-excursion} (@pxref{Window
Configurations}) in these functions, because that always counts as a
size change, and it would cause these functions to be called over and
over.  In most cases, @code{save-selected-window} (@pxref{Selecting
Windows}) is what you need here.
@end defvar

@defvar window-configuration-change-hook
A normal hook that is run every time you change the window configuration
of an existing frame.  This includes splitting or deleting windows,
changing the sizes of windows, or displaying a different buffer in a
window.

The buffer-local part of this hook is run once per each window on the
affected frame, with the relevant window selected and its buffer
current.  The global part is run once for the modified frame, with that
frame selected.
@end defvar

  In addition, you can use @code{jit-lock-register} to register a Font
Lock fontification function, which will be called whenever parts of a
buffer are (re)fontified because a window was scrolled or its size
changed.  @xref{Other Font Lock Variables}.
